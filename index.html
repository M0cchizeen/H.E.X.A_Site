<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HEXA - Painel de Combate</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --hexa-red: #FF3B30;
            --hexa-black: #0A0A0A;
            --hexa-blue: #11bcff;
            --hexa-yellow: #FFCC00;
            --hexa-white: #F0F0F0;
            --hexa-gray: #1A1A1A;
            --hexa-green: #34C759;
            --hexa-purple: #AF52DE;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--hexa-black);
            color: var(--hexa-white);
            font-family: 'Roboto Mono', monospace;
            min-height: 100vh;
            overflow-y: auto;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(255, 59, 48, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(0, 122, 255, 0.1) 0%, transparent 20%);
            position: relative;
        }

        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='%23007aff' fill-opacity='0.03' fill-rule='evenodd'/%3E%3C/svg%3E");
            opacity: 0.3;
            z-index: -1;
        }

        /* GLITCH EFFECT NO HEADER */
        .glitch {
            position: relative;
        }

        .glitch::before,
        .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .glitch::before {
            left: 2px;
            text-shadow: -2px 0 var(--hexa-blue);
            clip: rect(24px, 550px, 90px, 0);
            animation: glitch-anim 5s infinite linear alternate-reverse;
        }

        .glitch::after {
            left: -2px;
            text-shadow: -2px 0 var(--hexa-red);
            clip: rect(85px, 550px, 140px, 0);
            animation: glitch-anim2 5s infinite linear alternate-reverse;
        }

        @keyframes glitch-anim {
            0% { clip: rect(42px, 9999px, 44px, 0); }
            5% { clip: rect(12px, 9999px, 59px, 0); }
            10% { clip: rect(48px, 9999px, 29px, 0); }
            15% { clip: rect(42px, 9999px, 73px, 0); }
            20% { clip: rect(63px, 9999px, 27px, 0); }
            25% { clip: rect(34px, 9999px, 55px, 0); }
            30% { clip: rect(86px, 9999px, 73px, 0); }
            35% { clip: rect(20px, 9999px, 20px, 0); }
            40% { clip: rect(26px, 9999px, 60px, 0); }
            45% { clip: rect(25px, 9999px, 66px, 0); }
            50% { clip: rect(57px, 9999px, 98px, 0); }
            55% { clip: rect(5px, 9999px, 46px, 0); }
            60% { clip: rect(82px, 9999px, 31px, 0); }
            65% { clip: rect(54px, 9999px, 27px, 0); }
            70% { clip: rect(28px, 9999px, 99px, 0); }
            75% { clip: rect(45px, 9999px, 69px, 0); }
            80% { clip: rect(23px, 9999px, 85px, 0); }
            85% { clip: rect(54px, 9999px, 84px, 0); }
            90% { clip: rect(45px, 9999px, 47px, 0); }
            95% { clip: rect(37px, 9999px, 99px, 0); }
            100% { clip: rect(4px, 9999px, 43px, 0); }
        }

        @keyframes glitch-anim2 {
            0% { clip: rect(65px, 9999px, 100px, 0); }
            5% { clip: rect(52px, 9999px, 74px, 0); }
            10% { clip: rect(79px, 9999px, 85px, 0); }
            15% { clip: rect(75px, 9999px, 5px, 0); }
            20% { clip: rect(67px, 9999px, 61px, 0); }
            25% { clip: rect(14px, 9999px, 79px, 0); }
            30% { clip: rect(1px, 9999px, 66px, 0); }
            35% { clip: rect(86px, 9999px, 30px, 0); }
            40% { clip: rect(23px, 9999px, 98px, 0); }
            45% { clip: rect(85px, 9999px, 72px, 0); }
            50% { clip: rect(71px, 9999px, 75px, 0); }
            55% { clip: rect(2px, 9999px, 48px, 0); }
            60% { clip: rect(30px, 9999px, 16px, 0); }
            65% { clip: rect(59px, 9999px, 50px, 0); }
            70% { clip: rect(41px, 9999px, 62px, 0); }
            75% { clip: rect(2px, 9999px, 82px, 0); }
            80% { clip: rect(47px, 9999px, 73px, 0); }
            85% { clip: rect(3px, 9999px, 27px, 0); }
            90% { clip: rect(40px, 9999px, 86px, 0); }
            95% { clip: rect(45px, 9999px, 72px, 0); }
            100% { clip: rect(23px, 9999px, 49px, 0); }
        }

        /* CONTAINER PRINCIPAL */
        .combat-container {
            display: grid;
            grid-template-columns: 1fr 300px;
            grid-template-rows: 100px 1fr 120px;
            min-height: 100vh;
            height: auto;
            gap: 15px;
            padding: 20px;
        }

        /* HEADER */
        .header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(26, 26, 26, 0.8);
            border-radius: 15px;
            padding: 0 30px;
            border: 2px solid var(--hexa-red);
            box-shadow: 0 0 25px rgba(255, 59, 48, 0.3);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--hexa-red), var(--hexa-blue), var(--hexa-yellow));
        }

        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            font-weight: 900;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .logo-hexa {
            color: var(--hexa-blue);
            text-shadow: 0 0 10px rgba(91, 230, 255, 0.7);
        }

        .logo-supernova {
            color: var(--hexa-blue);
            text-shadow: 0 0 10px rgba(0, 122, 255, 0.7);
        }

        .turn-display {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 15px;
        }

        .turn-number {
            font-family: 'Orbitron', sans-serif;
            font-size: 3.5rem;
            color: var(--hexa-yellow);
            text-shadow: 0 0 15px rgba(255, 204, 0, 0.7);
            line-height: 1;
        }

        .turn-label {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.8rem;
            letter-spacing: 2px;
            color: var(--hexa-white);
        }

        .combat-time {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: var(--hexa-green);
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 10px;
            border: 1px solid var(--hexa-green);
        }

        /* ÁREA PRINCIPAL */
        .main-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        /* CARTÃO DO PERSONAGEM ATIVO */
        .active-character {
            background: linear-gradient(145deg, rgba(26, 26, 26, 0.9), rgba(10, 10, 10, 0.9));
            border-radius: 20px;
            padding: 25px;
            border: 3px solid var(--hexa-yellow);
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.4);
            position: relative;
            overflow: hidden;
        }

        .active-character::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, var(--hexa-yellow), var(--hexa-red), var(--hexa-yellow));
        }

        .character-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 25px;
        }

        .character-avatar {
            width: 120px;
            height: 120px;
            border-radius: 15px;
            border: 3px solid var(--hexa-blue);
            overflow: hidden;
            background: linear-gradient(45deg, #1a1a1a, #333);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
        }

        .character-info h2 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2.8rem;
            letter-spacing: 2px;
            color: var(--hexa-white);
            margin-bottom: 5px;
        }

        .character-archetype {
            font-family: 'Orbitron', sans-serif;
            color: var(--hexa-purple);
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        /* BARRAS DE STATUS */
        .status-bars {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
        }

        .bar-container {
            display: flex;
            align-items: center;
            gap: 15px;
            width: 100%;
        }

        .bar-label {
            width: 60px;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            letter-spacing: 1px;
            color: var(--hexa-white);
        }

        .bar {
            position: relative;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 5px;
            flex: 1;
            min-width: 200px;
        }

        .bar-fill {
            height: 100%;
            border-radius: 12px;
            transition: width 0.5s ease;
        }

        .hp-bar .bar-fill {
            background: linear-gradient(90deg, var(--hexa-red), #ff6b6b);
        }

        .co-bar .bar-fill {
            background: linear-gradient(90deg, var(--hexa-blue), #4a90e2);
        }

        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 0.9rem;
            color: white;
            cursor: pointer;
            padding: 2px 8px;
            border-radius: 4px;
            transition: background 0.3s;
            z-index: 10;
        }

        .bar-text:hover {
            background: rgba(0, 0, 0, 0.5);
        }

        .bar-adjust-buttons {
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            gap: 2px;
            z-index: 15;
        }

        .bar-adjust-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-weight: bold;
        }

        .bar-adjust-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .bar-adjust-btn:active {
            transform: scale(0.9);
        }

        /* STATUS EFEITOS */
        .status-effects {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 25px;
        }

        /* Protocolos collapsible dentro do cartão ativo */
        .protocols-container {
            margin-top: 8px;
        }

        .protocols-toggle {
            background: transparent;
            border: none;
            color: var(--hexa-white);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.05rem;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .protocols-list {
            margin-top: 10px;
            display: none;
            max-height: 120px; /* limita a altura e permite scroll */
            overflow-y: auto;
            padding-right: 6px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .protocols-list .effect-tag {
            padding: 4px 10px;
            font-size: 0.85rem;
        }

        .effect-tag {
            background: rgba(0, 122, 255, 0.2);
            border: 1px solid var(--hexa-blue);
            border-radius: 20px;
            padding: 5px 15px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .effect-tag.positive {
            background: rgba(52, 199, 89, 0.2);
            border-color: var(--hexa-green);
        }

        .effect-tag.negative {
            background: rgba(255, 59, 48, 0.2);
            border-color: var(--hexa-red);
        }

        /* AÇÕES RÁPIDAS */
        .quick-actions {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .action-btn {
            background: linear-gradient(145deg, rgba(255, 59, 48, 0.9), rgba(200, 40, 30, 0.9));
            border: none;
            border-radius: 12px;
            color: white;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.4rem;
            letter-spacing: 1px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            text-transform: uppercase;
        }

        .action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(255, 59, 48, 0.4);
        }

        .action-btn.blue {
            background: linear-gradient(145deg, rgba(0, 122, 255, 0.9), rgba(0, 90, 200, 0.9));
        }

        .action-btn.blue:hover {
            box-shadow: 0 5px 15px rgba(0, 122, 255, 0.4);
        }

        .action-btn.yellow {
            background: linear-gradient(145deg, rgba(255, 204, 0, 0.9), rgba(220, 170, 0, 0.9));
        }

        .action-btn.yellow:hover {
            box-shadow: 0 5px 15px rgba(255, 204, 0, 0.4);
        }

        .action-btn.purple {
            background: linear-gradient(145deg, var(--hexa-purple), #8e2de2);
        }

        .action-btn.purple:hover {
            box-shadow: 0 5px 15px rgba(175, 82, 222, 0.4);
        }

        .action-btn.green {
            background: linear-gradient(145deg, var(--hexa-green), #28a745);
        }

        .action-btn.green:hover {
            box-shadow: 0 5px 15px rgba(52, 199, 89, 0.4);
        }

        /* LOG DE AÇÕES */
        .action-log {
            background: rgba(26, 26, 26, 0.8);
            border-radius: 20px;
            padding: 20px;
            border: 2px solid var(--hexa-blue);
            overflow: hidden;
        }

        .log-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.8rem;
            letter-spacing: 1px;
            margin-bottom: 15px;
            color: var(--hexa-blue);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .log-content {
            height: 300px;
            overflow-y: auto;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .log-entry {
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid var(--hexa-yellow);
        }

        .log-entry.turn {
            border-left-color: var(--hexa-yellow);
            background: rgba(255, 204, 0, 0.1);
        }

        .log-entry.damage {
            border-left-color: var(--hexa-red);
            background: rgba(255, 59, 48, 0.1);
        }

        .log-entry.heal {
            border-left-color: var(--hexa-green);
            background: rgba(52, 199, 89, 0.1);
        }

        /* BARRA LATERAL - ORDEM DE INICIATIVA */
        .initiative-sidebar {
            grid-row: 2;
            grid-column: 2;
            background: rgba(26, 26, 26, 0.8);
            border-radius: 20px;
            padding: 20px;
            border: 2px solid var(--hexa-purple);
            overflow-y: auto;
        }

        .sidebar-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2rem;
            letter-spacing: 2px;
            margin-bottom: 20px;
            color: var(--hexa-purple);
            text-align: center;
            border-bottom: 2px solid var(--hexa-purple);
            padding-bottom: 10px;
        }

        .initiative-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .initiative-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .initiative-item.active {
            border-color: var(--hexa-yellow);
            background: rgba(255, 204, 0, 0.1);
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.3);
        }

        .initiative-item.next {
            border-color: var(--hexa-blue);
            background: rgba(0, 122, 255, 0.1);
        }

        .initiative-avatar {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            border: 2px solid var(--hexa-blue);
            background: linear-gradient(45deg, #1a1a1a, #333);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .initiative-info {
            flex: 1;
        }

        .initiative-name {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.4rem;
            letter-spacing: 1px;
        }

        .initiative-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
        }

        .initiative-value {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            color: var(--hexa-yellow);
            background: rgba(0, 0, 0, 0.5);
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 1.1rem;
            min-width: 40px;
            text-align: center;
        }

        /* FOOTER */
        .footer {
            grid-column: 1 / -1;
            background: rgba(26, 26, 26, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid var(--hexa-green);
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }

        .turn-summary {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .summary-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            letter-spacing: 1px;
            color: var(--hexa-green);
        }

        .summary-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            color: var(--hexa-white);
        }

        .control-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .control-btn {
            background: linear-gradient(145deg, rgba(255, 59, 48, 0.9), rgba(200, 40, 30, 0.9));
            border: none;
            border-radius: 10px;
            color: white;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            letter-spacing: 1px;
            padding: 12px 20px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 150px;
            text-transform: uppercase;
        }

        .control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(255, 59, 48, 0.4);
        }

        .control-btn.blue {
            background: linear-gradient(145deg, rgba(0, 122, 255, 0.9), rgba(0, 90, 200, 0.9));
        }

        .control-btn.blue:hover {
            box-shadow: 0 5px 15px rgba(0, 122, 255, 0.4);
        }

        /* ESTILOS PARA SEÇÃO DE ITENS */
        .item-actions {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .items-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .item-card {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s;
        }

        .item-card:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-2px);
        }

        .item-info {
            flex: 1;
        }

        .item-name {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            color: var(--hexa-white);
            margin-bottom: 4px;
        }

        .item-effect {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 4px;
        }

        .item-details {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
        }

        .item-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .item-btn {
            background: linear-gradient(145deg, rgba(0, 122, 255, 0.9), rgba(0, 90, 200, 0.9));
            border: none;
            border-radius: 6px;
            color: white;
            padding: 6px 12px;
            cursor: pointer;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .item-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(0, 122, 255, 0.4);
        }

        .item-btn.use {
            background: linear-gradient(145deg, var(--hexa-green), #28a745);
        }

        .item-btn.use:hover {
            box-shadow: 0 3px 10px rgba(52, 199, 89, 0.4);
        }

        .empty-items {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            padding: 20px;
        }

        /* MODAL PARA ADICIONAR ITENS */
        .item-modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .item-modal {
            background: linear-gradient(145deg, #1a1a1a, #0f0f0f);
            border: 2px solid var(--hexa-green);
            padding: 25px;
            border-radius: 15px;
            width: 450px;
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
        }

        .item-modal h3 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.8rem;
            color: var(--hexa-green);
            margin-bottom: 20px;
            text-align: center;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            color: var(--hexa-white);
            margin-bottom: 5px;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 10px;
            color: var(--hexa-white);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--hexa-green);
            box-shadow: 0 0 10px rgba(52, 199, 89, 0.3);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 60px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .modal-btn {
            background: linear-gradient(145deg, var(--hexa-green), #28a745);
            border: none;
            border-radius: 8px;
            color: white;
            padding: 10px 20px;
            cursor: pointer;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1rem;
            transition: all 0.3s;
        }

            .modal-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(52, 199, 89, 0.4);
            }

            .modal-btn.cancel {
                background: linear-gradient(145deg, var(--hexa-red), #dc3545);
            }

            .modal-btn.cancel:hover {
                box-shadow: 0 5px 15px rgba(255, 59, 48, 0.4);
            }

            /* ESTILOS PARA MODAL DE SELEÇÃO DE ALVO */
            .targets-list {
                display: flex;
                flex-direction: column;
                gap: 10px;
                max-height: 300px;
                overflow-y: auto;
                margin-bottom: 20px;
            }

            .target-item {
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                padding: 12px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                transition: all 0.3s;
                cursor: pointer;
            }

            .target-item:hover {
                background: rgba(255, 255, 255, 0.12);
                transform: translateY(-2px);
                border-color: var(--hexa-green);
            }

            .target-item.active {
                background: rgba(52, 199, 89, 0.1);
                border-color: var(--hexa-green);
                box-shadow: 0 0 15px rgba(52, 199, 89, 0.3);
            }

            .target-info {
                flex: 1;
            }

            .target-name {
                font-family: 'Bebas Neue', sans-serif;
                font-size: 1.1rem;
                color: var(--hexa-white);
                margin-bottom: 4px;
            }

            .target-stats {
                font-size: 0.85rem;
                color: rgba(255, 255, 255, 0.7);
                margin-bottom: 4px;
            }

            .target-avatar {
                width: 40px;
                height: 40px;
                border-radius: 8px;
                border: 2px solid var(--hexa-blue);
                background: linear-gradient(45deg, #1a1a1a, #333);
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.2rem;
            }

        /* Modal para repositório de fichas */
        .sheet-modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .sheet-modal {
            background: #0f0f0f;
            border: 2px solid var(--hexa-purple);
            padding: 20px;
            border-radius: 12px;
            width: 420px;
            max-height: 70vh;
            overflow-y: auto;
        }
        .sheet-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            background: rgba(255,255,255,0.03);
        }
        .sheet-item button {
            background: linear-gradient(145deg, rgba(0,122,255,0.9), rgba(0,90,200,0.9));
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
        }

        /* LISTA DE PERSONAGENS (CARREGADA DO LOCAL STORAGE) */
        #character-list {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 12px;
            border: 2px solid var(--hexa-purple);
        }

        #character-list p {
            margin: 0;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            color: var(--hexa-white);
        }

        #character-list button {
            background: var(--hexa-red);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1rem;
            margin-top: 10px;
            transition: background 0.3s;
        }

        #character-list button:hover {
            background: #c62828;
        }
    </style>
</head>
<body>
    <div class="combat-container">
        <!-- HEADER -->
        <header class="header">
            <div class="logo">
                <span class="logo-hexa">H.E.X.A</span> 
                <span class="logo-supernova"></span>
            </div>
            
            <div class="turn-display">
                <div class="turn-label">RODADAS</div>
                <div class="turn-number" id="roundsDisplay" style="font-size:1.2rem;">00</div>
                <div class="turn-label" style="font-size:0.9rem; margin-left:10px;">TURNO</div>
                <div class="turn-number" id="currentTurn" style="font-size:0.9rem; margin-left:5px;">00</div>
            </div>
            
            <div class="combat-time">
                <i class="fas fa-clock"></i> <span id="combatTimer">00:00</span>
            </div>
        </header>
        
        <!-- ÁREA PRINCIPAL -->
        <main class="main-area">
            <!-- CARTÃO DO PERSONAGEM ATIVO -->
            <section class="active-character">
                <div class="character-header">
                    <div class="character-avatar">
                        <i class="fas fa-user-ninja"></i>
                    </div>
                        <div class="character-info">
                        <h2 id="activeCharacterName">ARISCO</h2>
                        <div class="character-archetype"></div>
                        <div class="character-status" id="characterStatus"></div>
                        <!-- sample status tags (hidden template for later use) -->
                        <template id="statusSample" style="display:none">
                            <span class="effect-tag positive"><i class="fas fa-bullseye"></i> VANTAGEM</span>
                            <span class="effect-tag positive"><i class="fas fa-shield-alt"></i> DEF +2</span>
                            <span class="effect-tag negative"><i class="fas fa-tint"></i> SANGRANDO</span>
                        </template>
                    </div>
                </div>
                
                <div class="status-bars">
                    <div class="bar-container">
                        <div class="bar-label">PV</div>
                        <div class="bar hp-bar">
                            <div class="bar-fill" id="hpBar" style="width: 75%"></div>
                            <div class="bar-text" id="hpText" onclick="editStat('hp')">45/60</div>
                            <div class="bar-adjust-buttons">
                                <button class="bar-adjust-btn" onclick="adjustStat('hp', -1)">−</button>
                                <button class="bar-adjust-btn" onclick="adjustStat('hp', 1)">+</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="bar-container">
                        <div class="bar-label">CO</div>
                        <div class="bar co-bar">
                            <div class="bar-fill" id="coBar" style="width: 53%"></div>
                            <div class="bar-text" id="coText" onclick="editStat('co')">8/15</div>
                            <div class="bar-adjust-buttons">
                                <button class="bar-adjust-btn" onclick="adjustStat('co', -1)">−</button>
                                <button class="bar-adjust-btn" onclick="adjustStat('co', 1)">+</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="status-effects" id="statusEffects"></div>
                
                <div class="quick-actions" id="quickActions">
                    <button class="action-btn" onclick="takeAction('attack')">
                        <i class="fas fa-fist-raised"></i> ATACAR
                    </button>
                    <button class="action-btn blue" onclick="toggleSkillButtons()">
                        <i class="fas fa-bolt"></i> HABILIDADE
                    </button>
                    <button class="action-btn yellow" onclick="takeAction('move')">
                        <i class="fas fa-running"></i> MOVER
                    </button>
                    <button class="action-btn" onclick="takeAction('item')">
                        <i class="fas fa-briefcase-medical"></i> ITEM
                    </button>
                </div>
                <div class="skill-actions" id="skillActions" style="display:none;">
                    <button class="action-btn purple" onclick="useSkill('skill1')">
                        <i class="fas fa-fire"></i> Habilidade 1
                    </button>
                    <button class="action-btn purple" onclick="useSkill('skill2')">
                        <i class="fas fa-shield-alt"></i> Habilidade 2
                    </button>
                    <button class="action-btn purple" onclick="useSkill('skill3')">
                        <i class="fas fa-bolt"></i> Habilidade 3
                    </button>
                    <button class="action-btn purple" onclick="toggleSkillButtons()">
                        <i class="fas fa-arrow-left"></i> VOLTAR
                    </button>
                </div>
                <div class="item-actions" id="itemActions" style="display:none;">
                    <div class="items-list" id="itemsList">
                        <!-- Itens serão adicionados dinamicamente aqui -->
                    </div>
                    <div class="item-controls">
                        <button class="action-btn green" onclick="openAddItemModal()">
                            <i class="fas fa-plus"></i> ADICIONAR ITEM
                        </button>
                        <button class="action-btn purple" onclick="toggleItemButtons()">
                            <i class="fas fa-arrow-left"></i> VOLTAR
                        </button>
                    </div>
                </div>
                <div class="protocols-container">
                    <button id="protocolsToggle" class="protocols-toggle">Protocolos <span id="protocolsArrow">›</span></button>
                    <div id="protocolsList" class="protocols-list" aria-hidden="true"></div>
                </div>
            </section>
            
            <!-- LOG DE AÇÕES -->
            <section class="action-log">
                <div class="log-title">
                    <i class="fas fa-scroll"></i> LOG DE COMBATE
                </div>
                <div class="log-content" id="actionLog">
                    
                </div>
            </section>
        </main>
        
        <!-- BARRA LATERAL - ORDEM DE INICIATIVA -->
        <aside class="initiative-sidebar">
            <div class="sidebar-title">
                <i class="fas fa-list-ol"></i> ORDEM DE INICIATIVA
            </div>
            <div class="initiative-list" id="initiativeList">
                <!-- Itens serão gerados por JavaScript -->
            </div>
            <!-- Lista de fichas salvas / carregadas do localStorage -->
            <div id="character-list" style="margin-top:16px;"></div>
        </aside>
        
        <!-- FOOTER -->
        <footer class="footer">
            <div class="turn-summary">
                <div class="summary-title">DANO ESTE TURNO</div>
                <div class="summary-value" id="damageThisTurn">0</div>
            </div>
            
            <div class="turn-summary">
                <div class="summary-title">CO GASTO ESTE TURNO</div>
                <div class="summary-value" id="coSpentThisTurn">0</div>
            </div>
            
            <div class="control-buttons">
                <button class="control-btn" onclick="nextTurn()">
                    <i class="fas fa-forward"></i> PRÓXIMO TURNO
                </button>
                <button class="control-btn blue" onclick="rollInitiative()">
                    <i class="fas fa-dice-d20"></i> ROLAR INICIATIVA
                </button>
                    <button class="control-btn blue" onclick="window.open('pages/create_character.html','_blank')">
                        <i class="fas fa-file-circle-plus"></i> CRIAR FICHA
                    </button>
                <button class="control-btn" onclick="openAddModal()">
                    <i class="fas fa-user-plus"></i> ADICIONAR
                </button>
                <button class="control-btn" onclick="resetCombat()">
                    <i class="fas fa-undo"></i> RESETAR
                </button>
            </div>
        </footer>
    </div>

    <!-- MODAL DE FICHAS -->
    <div id="sheetModalContainer" style="display:none;"></div>

    <!-- MODAL PARA ADICIONAR ITENS -->
    <div id="itemModalContainer" style="display:none;"></div>

    <!-- BALÃO DE CRÍTICO (aparece quando necessário) -->
    <div class="critical-popup" id="criticalPopup" style="display: none;">
        <div> CRÍTICO! </div>
    </div>

    <script>
        // DADOS INICIAIS DO COMBATE (AGORA SEM NENHUM PERSONAGEM ATIVO)
        let combatData = {
            currentTurn: 0,
            rounds: 0,
            timer: 0, // segundos
            characters: [
                            ],
            damageThisTurn: 0,
            coSpentThisTurn: 0
        };

        // Sistema de controle de mudanças de stats por turno
        let statChanges = {};

        // REPOSITÓRIO DE FICHAS H.E.X.A
        const hexSheets = [
        ];

        // INICIALIZAR A INTERFACE
        function initCombat() {
            updateTurnDisplay();
            updateInitiativeList();
            updateTimer();
            updateActiveCharacter();
            updateSummary();
            setupProtocolsToggle();
            
            // Iniciar timer
            setInterval(updateTimer, 1000);
        }

        // ATUALIZAR DISPLAY DO TURNO E RODADAS
        function updateTurnDisplay() {
            document.getElementById('currentTurn').textContent = combatData.currentTurn.toString().padStart(2, '0');
            document.getElementById('roundsDisplay').textContent = combatData.rounds.toString().padStart(2, '0');
        }

        // ATUALIZAR LISTA DE INICIATIVA
        function updateInitiativeList() {
            const list = document.getElementById('initiativeList');
            list.innerHTML = '';
            
            // Ordenar por iniciativa (maior primeiro)
            const sortedChars = [...combatData.characters].sort((a, b) => b.initiative - a.initiative);
            
            sortedChars.forEach(char => {
                const item = document.createElement('div');
                item.className = 'initiative-item';
                if (char.isActive) item.classList.add('active');
                if (char.isNext) item.classList.add('next');

                const hpPercent = Math.round((char.hp / char.maxHp) * 100);
                const coPercent = Math.round((char.co / char.maxCo) * 100);

                item.innerHTML = `
                    <div class="initiative-avatar">${char.avatar}</div>
                    <div class="initiative-info">
                        <div class="initiative-name">${char.name}</div>
                        <div class="initiative-stats">
                            <span>HP: ${char.hp}/${char.maxHp}</span>
                            <span>CO: ${char.co}/${char.maxCo}</span>
                        </div>
                        <div class="progress-bar" style="height: 4px; background: rgba(255,255,255,0.1); margin-top: 5px; border-radius: 2px;">
                            <div style="height: 100%; width: ${hpPercent}%; background: ${hpPercent > 50 ? '#34C759' : hpPercent > 25 ? '#FF9500' : '#FF3B30'}; border-radius: 2px;"></div>
                        </div>
                    </div>
                    <div style="display:flex;flex-direction:column;align-items:center;gap:6px;">
                        <div class="initiative-value">${char.initiative}</div>
                        <button onclick="removeCombatCharacter(${char.id})" style="background:var(--hexa-red);border:none;color:#fff;padding:6px 8px;border-radius:6px;cursor:pointer;font-family:'Bebas Neue';font-size:0.85rem;">Remover</button>
                    </div>
                `;

                list.appendChild(item);
            });
        }

        // ATUALIZAR PERSONAGEM ATIVO (AGORA MANUSEIA SEM ATIVO)
        function updateActiveCharacter() {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) {
                document.getElementById('activeCharacterName').textContent = 'NENHUM';
                document.getElementById('hpBar').style.width = `0%`;
                document.getElementById('hpText').textContent = `-/-`;
                document.getElementById('hpText').setAttribute('onclick', "editStat('hp')");
                document.getElementById('coBar').style.width = `0%`;
                document.getElementById('coText').textContent = `-/-`;
                document.getElementById('coText').setAttribute('onclick', "editStat('co')");
                return;
            }
            
            document.getElementById('activeCharacterName').textContent = activeChar.name;
            // atualizar texto do arquétipo dinamicamente
            const archeEl = document.querySelector('.character-archetype');
            if (archeEl) archeEl.textContent = activeChar.archetype || '';
            
            const hpPercent = Math.round((activeChar.hp / activeChar.maxHp) * 100);
            const coPercent = Math.round((activeChar.co / activeChar.maxCo) * 100);
            
            document.getElementById('hpBar').style.width = `${hpPercent}%`;
            document.getElementById('hpText').textContent = `${activeChar.hp}/${activeChar.maxHp}`;
            document.getElementById('hpText').setAttribute('onclick', "editStat('hp')");
            
            document.getElementById('coBar').style.width = `${coPercent}%`;
            document.getElementById('coText').textContent = `${activeChar.co}/${activeChar.maxCo}`;
            document.getElementById('coText').setAttribute('onclick', "editStat('co')");

            // Carregar itens pendentes se houver
            try {
                // Carregar itens específicos deste personagem
                const characterKey = `characterItems_${activeChar.id}`;
                const savedItems = localStorage.getItem(characterKey);
                
                if (savedItems) {
                    const items = JSON.parse(savedItems);
                    if (Array.isArray(items) && items.length > 0) {
                        if (!activeChar.inventory) {
                            activeChar.inventory = [];
                        }
                        activeChar.inventory = items;
                        updateItemsList();
                    }
                } else {
                    // Tentar carregar do characterInfo geral
                    const characterInfo = localStorage.getItem('characterItems');
                    if (characterInfo) {
                        const info = JSON.parse(characterInfo);
                        if (info.characterId === activeChar.id && Array.isArray(info.items)) {
                            if (!activeChar.inventory) {
                                activeChar.inventory = [];
                            }
                            activeChar.inventory = info.items;
                            updateItemsList();
                        }
                    }
                }
                
                // Limpar itens pendentes genéricos se existirem
                localStorage.removeItem('pendingItems');
            } catch(e) {
                console.error('Erro ao carregar itens pendentes:', e);
            }

            // Resetar visualização para os 4 botões originais ao mudar de personagem
            try {
                const quickActions = document.getElementById('quickActions');
                const itemActions = document.getElementById('itemActions');
                if (quickActions && itemActions) {
                    quickActions.style.display = 'grid';
                    itemActions.style.display = 'none';
                }
            } catch(e) {
                console.error('Erro ao resetar visualização de ações:', e);
            }

            // limpar status-effects visíveis (não mostrar exemplos estáticos)
            try { const se = document.getElementById('statusEffects'); if (se) se.innerHTML = ''; } catch(e){}

            // render protocolos (mostrar somente com 1+ pontos) dentro do container recolhível
            try{
                const protocolos = activeChar.protocolos || {};
                const protocolListEl = document.getElementById('protocolsList');
                if (protocolListEl) {
                    protocolListEl.innerHTML = '';
                    Object.entries(protocolos).forEach(([key, val]) => {
                        if (val && val > 0) {
                            const tag = document.createElement('span');
                            tag.className = 'effect-tag';
                            tag.textContent = `${key} +${val}`;
                            protocolListEl.appendChild(tag);
                        }
                    });
                }
            } catch(e){}
        }

        // ATUALIZAR TIMER
        function updateTimer() {
            combatData.timer++;
            const minutes = Math.floor(combatData.timer / 60);
            const seconds = combatData.timer % 60;
            document.getElementById('combatTimer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // ATUALIZAR RESUMO
        function updateSummary() {
            document.getElementById('damageThisTurn').textContent = combatData.damageThisTurn;
            document.getElementById('coSpentThisTurn').textContent = combatData.coSpentThisTurn;
        }

        // PRÓXIMO TURNO (AGORA GERA RODADAS AO ENROLAR)
        function nextTurn() {
            const currentIndex = combatData.characters.findIndex(c => c.isActive);
            const nextIndex = (currentIndex + 1) % combatData.characters.length;
            
            // Registrar mudanças de stats antes de mudar o turno
            logStatChanges();
            
            // Resetar flags
            combatData.characters.forEach(c => {
                c.isActive = false;
                c.isNext = false;
            });
            
            // Se não havia personagem ativo (início), iniciar no índice 0 e turno 1
            if (currentIndex === -1) {
                combatData.characters[nextIndex].isActive = true;
                const nextNextIndex = (nextIndex + 1) % combatData.characters.length;
                combatData.characters[nextNextIndex].isNext = true;
                combatData.currentTurn = 1;
                combatData.rounds = 1; // Começa com 1 rodada
                // rounds permanece como está (não conta como fim de rodada)
            } else {
                // definir novo personagem ativo
                combatData.characters[nextIndex].isActive = true;
                const nextNextIndex = (nextIndex + 1) % combatData.characters.length;
                combatData.characters[nextNextIndex].isNext = true;
                
                // Se voltamos ao índice 0, significa nova rodada
                if (nextIndex === 0) {
                    combatData.rounds++;
                }
                
                // Incrementar turno contador
                combatData.currentTurn++;
            }
            
            combatData.damageThisTurn = 0;
            combatData.coSpentThisTurn = 0;
            
            // Removido o log de "TURNO X INICIADO"
            
            updateTurnDisplay();
            updateInitiativeList();
            updateActiveCharacter();
            updateSummary();
            
            playSoundEffect('nextTurn');
        }

        // ROLAR INICIATIVA (AGORA ZERA/INICIA RODADAS)
        function rollInitiative() {
            combatData.characters.forEach(char => {
                const roll = Math.floor(Math.random() * 20) + 1;
                const modifier = Math.floor(Math.random() * 5) + 1;
                char.initiative = roll + modifier;
            });
            
            combatData.characters.sort((a, b) => b.initiative - a.initiative);
            
            combatData.characters.forEach((c, i) => {
                c.isActive = i === 0;
                c.isNext = i === 1;
            });
            
            combatData.currentTurn = 1;
            combatData.rounds = 1;
            combatData.damageThisTurn = 0;
            combatData.coSpentThisTurn = 0;
            
            addLogEntry('INICIATIVA ROLADA - Nova ordem definida', 'turn');
            
            updateTurnDisplay();
            updateInitiativeList();
            updateActiveCharacter();
            updateSummary();
            
            playSoundEffect('diceRoll');
        }

        // ADICIONAR ENTRADA NO LOG
        function addLogEntry(text, type = '') {
            const log = document.getElementById('actionLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = text;
            
            log.insertBefore(entry, log.firstChild);
            
            // Manter log com no máximo 20 entradas
            if (log.children.length > 20) {
                log.removeChild(log.lastChild);
            }
        }

        // AÇÃO DO PERSONAGEM
        function takeAction(action) {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) return;
            
            // Se for ação de item, alternar para a tela de itens
            if (action === 'item') {
                toggleItemButtons();
                return;
            }
            
            const actions = {
                attack: { text: `${activeChar.name} atacou`, co: 0, damage: Math.floor(Math.random() * 20) + 5 },
                skill: { text: `${activeChar.name} usou uma habilidade`, co: 3, damage: Math.floor(Math.random() * 25) + 10 },
                move: { text: `${activeChar.name} se moveu`, co: 0, damage: 0 }
            };
            
            const act = actions[action];
            
            // Atualizar CO
            if (activeChar.co >= act.co) {
                activeChar.co -= act.co;
                combatData.coSpentThisTurn += act.co;
                
                // Adicionar dano se houver
                if (act.damage > 0) {
                    combatData.damageThisTurn += act.damage;
                    
                    // Chance de crítico (20%)
                    if (Math.random() < 0.2) {
                        showCriticalPopup();
                        act.damage *= 2;
                        act.text += ` (CRÍTICO! ${act.damage} de dano)`;
                    }
                }
                
                addLogEntry(act.text, 'damage');
                updateActiveCharacter();
                updateSummary();
                playSoundEffect('attack');
            } else {
                addLogEntry(`<strong>${activeChar.name}</strong> não tem CO suficiente para essa ação!`, 'damage');
            }
        }

        // ALTERNAR ENTRE BOTÕES DE AÇÃO E HABILIDADES
        function toggleSkillButtons() {
            const quickActions = document.getElementById('quickActions');
            const skillActions = document.getElementById('skillActions');
            
            if (quickActions.style.display === 'none') {
                quickActions.style.display = 'grid';
                skillActions.style.display = 'none';
            } else {
                quickActions.style.display = 'none';
                skillActions.style.display = 'grid';
            }
        }

        // USAR HABILIDADE ESPECÍFICA
        function useSkill(skillId) {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) return;
            
            const skills = {
                skill1: { name: 'Habilidade 1', co: 4, damage: Math.floor(Math.random() * 30) + 15, icon: '🔥' },
                skill2: { name: 'Habilidade 2', co: 3, damage: Math.floor(Math.random() * 25) + 10, icon: '🛡️' },
                skill3: { name: 'Habilidade 3', co: 5, damage: Math.floor(Math.random() * 35) + 20, icon: '⚡' }
            };
            
            const skill = skills[skillId];
            
            if (activeChar.co >= skill.co) {
                activeChar.co -= skill.co;
                combatData.coSpentThisTurn += skill.co;
                
                if (skill.damage > 0) {
                    combatData.damageThisTurn += skill.damage;
                    
                    // Chance de crítico maior para habilidades (25%)
                    if (Math.random() < 0.25) {
                        showCriticalPopup();
                        skill.damage *= 2;
                        addLogEntry(`${activeChar.name} usou ${skill.name} ${skill.icon} (CRÍTICO! ${skill.damage} de dano)`, 'damage');
                    } else {
                        addLogEntry(`${activeChar.name} usou ${skill.name} ${skill.icon} (${skill.damage} de dano)`, 'damage');
                    }
                } else {
                    addLogEntry(`${activeChar.name} usou ${skill.name} ${skill.icon}`, 'turn');
                }
                
                updateActiveCharacter();
                updateSummary();
                playSoundEffect('skill');
                
                // Voltar para os botões originais após usar a habilidade
                toggleSkillButtons();
            } else {
                addLogEntry(`${activeChar.name} não tem CO suficiente para ${skill.name}!`, 'turn');
                playSoundEffect('error');
            }
        }

        // ALTERNAR ENTRE BOTÕES DE AÇÃO E ITENS
        function toggleItemButtons() {
            const quickActions = document.getElementById('quickActions');
            const itemActions = document.getElementById('itemActions');
            
            if (quickActions.style.display === 'none') {
                quickActions.style.display = 'grid';
                itemActions.style.display = 'none';
            } else {
                quickActions.style.display = 'none';
                itemActions.style.display = 'grid';
                // Atualizar lista de itens ao abrir
                updateItemsList();
            }
        }

        // ABRIR MODAL PARA ADICIONAR ITEM
        function openAddItemModal() {
            const container = document.getElementById('itemModalContainer');
            
            const modalHtml = `
                <div class="item-modal-backdrop" onclick="closeItemModal(event)">
                    <div class="item-modal" onclick="event.stopPropagation()">
                        <h3><i class="fas fa-plus"></i> ADICIONAR NOVO ITEM</h3>
                        
                        <form id="addItemForm" onsubmit="addItem(event)">
                            <div class="form-group">
                                <label for="itemName">Nome do Item</label>
                                <input type="text" id="itemName" name="itemName" required placeholder="Ex: Poção de Cura">
                            </div>
                            
                            <div class="form-group">
                                <label for="itemEffect">Efeito do Item</label>
                                <textarea id="itemEffect" name="itemEffect" required placeholder="Ex: Restaura 20 pontos de vida"></textarea>
                            </div>
                            
                            <div class="form-row">
                                <div class="form-group">
                                    <label for="itemConsumable">É Consumível?</label>
                                    <select id="itemConsumable" name="itemConsumable" required onchange="toggleConsumableFields()">
                                        <option value="true">Sim</option>
                                        <option value="false">Não</option>
                                    </select>
                                </div>
                                
                                <div class="form-group" id="usesGroup">
                                    <label for="itemUses">Usos Restantes</label>
                                    <input type="number" id="itemUses" name="itemUses" min="0" value="1">
                                </div>
                            </div>
 　 　 　 　 　 　 　 　 　
                            <div class="form-row">
                                <div class="form-group">
                                    <label for="itemTargetable">Usável em Criaturas?</label>
                                    <select id="itemTargetable" name="itemTargetable" required>
                                        <option value="false">Apenas em si mesmo</option>
                                        <option value="true">Em qualquer criatura</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label for="itemSpace">Espaço no Inventário</label>
                                    <input type="number" id="itemSpace" name="itemSpace" min="1" value="1" required placeholder="Quantos espaços ocupa">
                                </div>
                            </div>
                            
                            <div class="modal-buttons">
                                <button type="button" class="modal-btn cancel" onclick="closeItemModal()">CANCELAR</button>
                                <button type="submit" class="modal-btn">ADICIONAR ITEM</button>
                            </div>
                        </form>
                    </div>
                </div>
            `;
            
            container.innerHTML = modalHtml;
            container.style.display = 'block';
        }

        // FECHAR MODAL DE ITENS
        function closeItemModal(e) {
            if (e && e.target !== e.currentTarget) return;
            const container = document.getElementById('itemModalContainer');
            container.style.display = 'none';
            container.innerHTML = '';
        }

        // ALTERNAR CAMPOS DE CONSUMÍVEL
        function toggleConsumableFields() {
            const isConsumable = document.getElementById('itemConsumable').value === 'true';
            const usesGroup = document.getElementById('usesGroup');
            
            if (isConsumable) {
                usesGroup.style.display = 'block';
                document.getElementById('itemUses').required = true;
            } else {
                usesGroup.style.display = 'none';
                document.getElementById('itemUses').required = false;
                document.getElementById('itemUses').value = '0';
            }
        }

        // ADICIONAR ITEM AO INVENTÁRIO
        function addItem(event) {
            event.preventDefault();
            
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) {
                addLogEntry('Nenhum personagem ativo para adicionar item!', 'turn');
                return;
            }
            
            const formData = new FormData(event.target);
            const isConsumable = formData.get('itemConsumable') === 'true';
            
            const newItem = {
                id: Date.now(), // ID único baseado no timestamp
                name: formData.get('itemName'),
                effect: formData.get('itemEffect'),
                consumable: isConsumable,
                uses: isConsumable ? parseInt(formData.get('itemUses')) : 0,
                targetable: formData.get('itemTargetable') === 'true',
                space: parseInt(formData.get('itemSpace'))
            };
            
            // Inicializar inventário se não existir
            if (!activeChar.inventory) {
                activeChar.inventory = [];
            }
            
            // Adicionar item ao inventário
            activeChar.inventory.push(newItem);
            
            // Sincronizar com a ficha
            syncItemsToSheet(activeChar.inventory);
            
            addLogEntry(`${activeChar.name} adicionou "${newItem.name}" ao inventário`, 'turn');
            playSoundEffect('itemAdd');
            
            // Fechar modal e atualizar lista
            closeItemModal();
            updateItemsList();
        }

        // Sincronizar itens com a ficha
        function syncItemsToSheet(items) {
            // Obter personagem ativo
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) {
                console.log('❌ SyncItemsToSheet - Nenhum personagem ativo');
                return;
            }
            
            console.log('🔄 SyncItemsToSheet - Personagem:', activeChar.name, 'Itens:', items.length);
            
            // Salvar itens específicos do personagem usando seu ID
            const characterKey = `characterItems_${activeChar.id}`;
            localStorage.setItem(characterKey, JSON.stringify(items));
            console.log('💾 Salvou itens em:', characterKey);
            
            // Salvar também informações do personagem para a ficha
            const characterInfo = {
                characterId: activeChar.id,
                characterName: activeChar.name,
                items: items
            };
            localStorage.setItem('characterItems', JSON.stringify(characterInfo));
            
            // Disparar evento para notificar outras páginas
            localStorage.setItem('itemsUpdated', Date.now().toString());
            console.log('📢 Evento itemsUpdated disparado da página principal');
        }

        // Carregar itens da ficha
        function loadItemsFromSheet() {
            console.log('📥 LoadItemsFromSheet - Iniciando carregamento');
            try {
                const activeChar = combatData.characters.find(c => c.isActive);
                if (!activeChar) {
                    console.log('❌ Nenhum personagem ativo encontrado');
                    // Se não houver personagem ativo, tentar carregar itens pendentes
                    const pendingItems = localStorage.getItem('pendingItems');
                    if (pendingItems) {
                        const items = JSON.parse(pendingItems);
                        if (Array.isArray(items) && items.length > 0) {
                            localStorage.setItem('pendingItems', JSON.stringify(items));
                        }
                    }
                    return;
                }
                
                console.log('✅ Personagem ativo:', activeChar.name, 'ID:', activeChar.id);
                
                // Tentar carregar itens específicos do personagem
                const characterKey = `characterItems_${activeChar.id}`;
                const savedItems = localStorage.getItem(characterKey);
                
                console.log('🔍 Procurando itens em:', characterKey);
                
                if (savedItems) {
                    const items = JSON.parse(savedItems);
                    if (Array.isArray(items)) {
                        if (!activeChar.inventory) {
                            activeChar.inventory = [];
                        }
                        activeChar.inventory = items;
                        updateItemsList();
                        console.log('✅ Itens carregados do personagem:', items.length);
                    }
                } else {
                    // Tentar carregar do characterInfo geral
                    const characterInfo = localStorage.getItem('characterItems');
                    if (characterInfo) {
                        const info = JSON.parse(characterInfo);
                        if (info.characterId === activeChar.id && Array.isArray(info.items)) {
                            if (!activeChar.inventory) {
                                activeChar.inventory = [];
                            }
                            activeChar.inventory = info.items;
                            updateItemsList();
                            console.log('✅ Itens carregados do characterInfo:', info.items.length);
                        }
                    }
                }
            } catch(e) {
                console.error('Erro ao carregar itens da ficha:', e);
            }
        }

        // ATUALIZAR LISTA DE ITENS
        function updateItemsList() {
            const activeChar = combatData.characters.find(c => c.isActive);
            const itemsList = document.getElementById('itemsList');
            
            if (!activeChar || !activeChar.inventory || activeChar.inventory.length === 0) {
                itemsList.innerHTML = '<div class="empty-items">Nenhum item no inventário</div>';
                return;
            }
            
            itemsList.innerHTML = '';
            
            activeChar.inventory.forEach(item => {
                const itemCard = document.createElement('div');
                itemCard.className = 'item-card';
                
                const usesText = item.consumable ? ` (${item.uses} usos)` : '';
                const spaceText = item.space > 1 ? ` [${item.space} espaços]` : '';
                
                itemCard.innerHTML = `
                    <div class="item-info">
                        <div class="item-name">${item.name}${usesText}${spaceText}</div>
                        <div class="item-effect">${item.effect}</div>
                        <div class="item-details">${item.consumable ? 'Consumível' : 'Permanente'}</div>
                    </div>
                    <div class="item-controls">
                        ${item.consumable && item.uses > 0 ? 
                            `<button class="item-btn use" onclick="useItem('${item.id}')">USAR</button>` : 
                            item.consumable ? 
                            `<button class="item-btn" disabled>ESGOTADO</button>` : 
                            `<button class="item-btn use" onclick="useItem('${item.id}')">USAR</button>`
                        }
                        <button class="item-btn" onclick="removeItem('${item.id}')">REMOVER</button>
                    </div>
                `;
                itemsList.appendChild(itemCard);
            });
        }

        // USAR ITEM
        function useItem(itemId) {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) return;
            
            const item = activeChar.inventory.find(i => i.id == itemId);
            if (!item) return;
            
            // Verificar se item pode ser usado em outras criaturas
            if (item.targetable) {
                // Abrir modal de seleção de alvo
                openTargetSelectionModal(itemId);
            } else {
                // Usar diretamente no personagem ativo
                applyItemEffect(activeChar, item, activeChar);
            }
        }

        // ABRIR MODAL DE SELEÇÃO DE ALVO
        function openTargetSelectionModal(itemId) {
            const activeChar = combatData.characters.find(c => c.isActive);
            const item = activeChar.inventory.find(i => i.id == itemId);
            if (!item) return;
            
            const container = document.getElementById('itemModalContainer');
            
            // Gerar HTML com lista de personagens como alvos
            let targetsHtml = '';
            combatData.characters.forEach(char => {
                const hpPercent = Math.round((char.hp / char.maxHp) * 100);
                const isActive = char.isActive ? 'active' : '';
                const statusIcon = char.isActive ? '⭐' : '';
                
                targetsHtml += `
                    <div class="target-item ${isActive}" onclick="selectTarget('${itemId}', '${char.id}')">
                        <div class="target-info">
                            <div class="target-name">${char.name} ${statusIcon}</div>
                            <div class="target-stats">
                                <span>HP: ${char.hp}/${char.maxHp}</span>
                                <span>CO: ${char.co}/${char.maxCo}</span>
                            </div>
                            <div class="progress-bar" style="height: 4px; background: rgba(255,255,255,0.1); margin-top: 5px; border-radius: 2px;">
                                <div style="height: 100%; width: ${hpPercent}%; background: ${hpPercent > 50 ? '#34C759' : hpPercent > 25 ? '#FF9500' : '#FF3B30'}; border-radius: 2px;"></div>
                            </div>
                        </div>
                        <div class="target-avatar">${char.avatar}</div>
                    </div>
                `;
            });
            
            const modalHtml = `
                <div class="item-modal-backdrop" onclick="closeTargetSelectionModal(event)">
                    <div class="item-modal" onclick="event.stopPropagation()">
                        <h3><i class="fas fa-crosshairs"></i> SELECIONAR ALVO PARA ${item.name.toUpperCase()}</h3>
                        <p style="color: rgba(255,255,255,0.7); margin-bottom: 20px;">Escolha quem receberá o efeito: ${item.effect}</p>
                        
                        <div class="targets-list">
                            ${targetsHtml}
                        </div>
                        
                        <div class="modal-buttons">
                            <button type="button" class="modal-btn cancel" onclick="closeTargetSelectionModal()">CANCELAR</button>
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = modalHtml;
            container.style.display = 'block';
        }

        // FECHAR MODAL DE SELEÇÃO DE ALVO
        function closeTargetSelectionModal(e) {
            if (e && e.target !== e.currentTarget) return;
            const container = document.getElementById('itemModalContainer');
            container.style.display = 'none';
            container.innerHTML = '';
        }

        // SELECIONAR ALVO E APLICAR ITEM
        function selectTarget(itemId, targetId) {
            const activeChar = combatData.characters.find(c => c.isActive);
            const targetChar = combatData.characters.find(c => c.id == targetId);
            const item = activeChar.inventory.find(i => i.id == itemId);
            
            if (!targetChar || !item) return;
            
            // Aplicar efeito no alvo
            applyItemEffect(activeChar, item, targetChar);
            
            // Fechar modal
            closeTargetSelectionModal();
        }

        // APLICAR EFEITO DO ITEM
        function applyItemEffect(userChar, item, targetChar) {
            // Verificar se o item pode ser usado
            if (item.consumable && item.uses <= 0) {
                addLogEntry(`${item.name} não tem usos restantes!`, 'turn');
                return;
            }
            
            let effectMessage = '';
            let logType = 'turn';
            
            // Verificar se é uma poção de cura
            if (item.name.toLowerCase().includes('cura') || item.effect.toLowerCase().includes('vida') || item.effect.toLowerCase().includes('cura')) {
                const healAmount = 20; // Valor fixo por enquanto
                const actualHeal = Math.min(healAmount, targetChar.maxHp - targetChar.hp);
                targetChar.hp += actualHeal;
                effectMessage = ` (curou ${actualHeal} PV)`;
                logType = 'heal';
            }
            // Verificar se é uma poção de CO/energia
            else if (item.name.toLowerCase().includes('co') || item.name.toLowerCase().includes('energia') || item.effect.toLowerCase().includes('co')) {
                const restoreAmount = 5; // Valor fixo por enquanto
                const actualRestore = Math.min(restoreAmount, targetChar.maxCo - targetChar.co);
                targetChar.co += actualRestore;
                effectMessage = ` (restaurou ${actualRestore} CO)`;
                logType = 'turn';
            }
            else {
                // Efeito genérico
                effectMessage = ` - ${item.effect}`;
                logType = 'turn';
            }
            
            // Mensagem de log diferenciada para uso em si mesmo vs outros
            if (userChar.id === targetChar.id) {
                addLogEntry(`${userChar.name} usou ${item.name} em si mesmo${effectMessage}`, logType);
            } else {
                addLogEntry(`${userChar.name} usou ${item.name} em ${targetChar.name}${effectMessage}`, logType);
            }
            
            // Reduzir usos se for consumível
            if (item.consumable) {
                item.uses--;
                
                // Remover item se usos chegaram a 0
                if (item.uses <= 0) {
                    const itemIndex = userChar.inventory.findIndex(i => i.id == item.id);
                    userChar.inventory.splice(itemIndex, 1);
                    addLogEntry(`${item.name} foi completamente usado e removido do inventário`, 'turn');
                    
                    // Sincronizar remoção com a ficha
                    syncItemsToSheet(userChar.inventory);
                } else {
                    // Sincronizar redução de usos com a ficha
                    syncItemsToSheet(userChar.inventory);
                }
            }
            
            // Atualizar interface
            updateActiveCharacter();
            updateInitiativeList();
            updateItemsList();
            playSoundEffect('itemUse');
        }

        // REMOVER ITEM DO INVENTÁRIO
        function removeItem(itemId) {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) return;
            
            const itemIndex = activeChar.inventory.findIndex(i => i.id == itemId);
            if (itemIndex === -1) return;
            
            const removedItem = activeChar.inventory[itemIndex];
            activeChar.inventory.splice(itemIndex, 1);
            
            // Sincronizar com a ficha
            syncItemsToSheet(activeChar.inventory);
            
            addLogEntry(`${activeChar.name} removeu "${removedItem.name}" do inventário`, 'turn');
            updateItemsList();
            playSoundEffect('itemRemove');
        }

        // MOSTRAR POPUP DE CRÍTICO
        function showCriticalPopup() {
            const popup = document.getElementById('criticalPopup');
            popup.style.display = 'block';
            
            // Reproduzir som de crítico (simulado)
            playSoundEffect('critical');
            
            // Remover após 1.5 segundos
            setTimeout(() => {
                popup.style.display = 'none';
            }, 1500);
        }

        // ABRIR MODAL DE ADIÇÃO E ESCOLHA DE FICHA
        function openAddModal() {
            const container = document.getElementById('sheetModalContainer');
            const saved = JSON.parse(localStorage.getItem('sheetRepo')) || [];
            const allSheets = [...hexSheets, ...saved];

            // construir HTML do modal usando propriedades seguras (suporta sheet.meta/recursos)
            let modalHtml = `
                <div class="sheet-modal-backdrop" onclick="closeSheetModal(event)">
                    <div class="sheet-modal" onclick="event.stopPropagation()">
                        <h3 style="margin-bottom:10px;">Repositório H.E.X.A - Escolha uma ficha</h3>
            `;

            allSheets.forEach(s => {
                const name = s.name || (s.meta && (s.meta.name || s.meta.nome)) || '';
                const avatar = s.avatar || (s.meta && s.meta.avatar) || '';
                const arche = s.archetype || (s.meta && (s.meta.archetype || s.meta.arquetipo)) || '';
                const pv = (s.hp != null) ? s.hp : (s.recursos && s.recursos.vitalidade) || (s.meta && (s.meta.vitalidade || s.meta.vit_atual)) || '-';
                const maxPv = (s.maxHp != null) ? s.maxHp : (s.recursos && s.recursos.vitalidade) || (s.meta && (s.meta.vitalidade || s.meta.vit_max)) || '-';
                // unified carga-operacional: prefer recursos.carga_operacional, then carga_atual / carga_maxima, then meta fallbacks
                const coVal = (s.co != null) ? s.co : (s.recursos && (s.recursos.carga_operacional != null ? s.recursos.carga_operacional : (s.recursos.carga_atual != null ? s.recursos.carga_atual : s.recursos.carga_maxima))) || (s.meta && (s.meta.co || s.meta.co_atual)) || '-';
                const maxCoVal = (s.maxCo != null) ? s.maxCo : (s.recursos && (s.recursos.carga_operacional != null ? s.recursos.carga_operacional : (s.recursos.carga_maxima != null ? s.recursos.carga_maxima : s.recursos.carga_atual))) || (s.meta && (s.meta.maxCo || s.meta.carga_maxima)) || '-';

                modalHtml += `
                    <div class="sheet-item" id="sheet-${s.sheetId}">
                        <div>
                            <div style="font-size:1.1rem;"><strong>${name}</strong> ${avatar}</div>
                            <div style="font-size:0.85rem; color:rgba(255,255,255,0.7)">${arche} — PV ${pv} / ${maxPv} • CO ${coVal} / ${maxCoVal}</div>
                        </div>
                        <div style="display:flex;flex-direction:column;gap:6px;">
                            <button onclick="addCharFromSheet('${s.sheetId}')">Adicionar</button>
                            <button onclick="editSheet('${s.sheetId}')" style="background:#444;color:#fff;padding:6px;border-radius:6px;border:none;cursor:pointer;">Editar</button>
                            <button onclick="deleteSheetFromRepo('${s.sheetId}')" style="background:#b71c1c;color:#fff;padding:6px;border-radius:6px;border:none;cursor:pointer;">Excluir</button>
                        </div>
                    </div>
                `;
            });

            modalHtml += `
                        <div style="text-align:right; margin-top:8px;">
                            <button onclick="closeSheetModal()" style="background:#444; color:#fff; padding:6px 10px; border-radius:8px; border:none; cursor:pointer;">Fechar</button>
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = modalHtml;
            container.style.display = 'block';
        }

        function closeSheetModal(e) {
            if (e && e.target !== e.currentTarget) return;
            const container = document.getElementById('sheetModalContainer');
            container.style.display = 'none';
            container.innerHTML = '';
        }

        // ADICIONA UMA FICHA ESCOLHIDA AO COMBATE
        function addCharFromSheet(sheetId) {
            const saved = JSON.parse(localStorage.getItem('sheetRepo')) || [];
            const sheet = hexSheets.find(s => s.sheetId === sheetId) || saved.find(s => s.sheetId === sheetId);
            if (!sheet) return;

            // suportar formatos antigos (flat) e novos (com meta/atributos/recursos)
            const name = sheet.name || (sheet.meta && sheet.meta.name) || 'Sem nome';
            const archetype = sheet.archetype || (sheet.meta && sheet.meta.archetype) || (sheet.meta && sheet.meta.archetype) || '';
            const avatar = sheet.avatar || (sheet.meta && sheet.meta.avatar) || sheet.avatar || '🙂';
            const hp = (sheet.hp != null) ? sheet.hp : (sheet.recursos && sheet.recursos.vitalidade) || (sheet.meta && sheet.meta.vitalidade) || 0;
            const maxHp = (sheet.maxHp != null) ? sheet.maxHp : (sheet.recursos && sheet.recursos.vitalidade) || hp || 0;
            // set both current and max CO from unified carga_operacional when available
            const coFromRecursos = sheet.recursos && (sheet.recursos.carga_operacional != null ? sheet.recursos.carga_operacional : (sheet.recursos.carga_atual != null ? sheet.recursos.carga_atual : sheet.recursos.carga_maxima));
            const co = (sheet.co != null) ? sheet.co : (coFromRecursos != null ? coFromRecursos : 0);
            const maxCo = (sheet.maxCo != null) ? sheet.maxCo : (coFromRecursos != null ? coFromRecursos : co || 0);
            const initiative = sheet.initiative || Math.floor(Math.random()*20)+1;

            const newChar = {
                id: sheetId, // Usar o sheetId original em vez de ID numérico
                name,
                hp: Number(hp),
                maxHp: Number(maxHp),
                co: Number(co),
                maxCo: Number(maxCo),
                initiative,
                avatar,
                isActive: false,
                isNext: false,
                archetype,
                protocolos: sheet.protocolos || {}
            };
            combatData.characters.push(newChar);
            updateInitiativeList();
            addLogEntry(`<strong>${newChar.name}</strong> entrou no combate`);
            playSoundEffect('characterAdd');
            closeSheetModal();
        }

        // Deleta uma ficha do repositório (usuário)
        function deleteSheetFromRepo(sheetId) {
            const sheetRepo = JSON.parse(localStorage.getItem('sheetRepo')) || [];
            const idx = sheetRepo.findIndex(s => s.sheetId === sheetId);
            if (idx === -1) return;
            const removed = sheetRepo.splice(idx, 1)[0];
            localStorage.setItem('sheetRepo', JSON.stringify(sheetRepo));
            localStorage.setItem('sheetRepoUpdated', JSON.stringify({ sheetId: sheetId, action: 'deleted', time: Date.now() }));
            const removedName = (removed && (removed.name || (removed.meta && (removed.meta.name || removed.meta.nome)))) || 'Sem nome';
            addLogEntry(`<strong>${removedName}</strong> foi removido do repositório`);
            // atualizar modal
            openAddModal();
        }

        // Abrir a ficha para edição em nova aba
        function editSheet(sheetId) {
            // abrir a página de criação com parâmetro ?edit=sheetId
            window.open('pages/create_character.html?edit=' + encodeURIComponent(sheetId), '_blank');
        }

        // RESETAR TIMER E CONTADORES
        function resetCombat() {
            combatData.timer = 0;
            combatData.currentTurn = 0;
            combatData.rounds = 0;
            combatData.damageThisTurn = 0;
            combatData.coSpentThisTurn = 0;
            combatData.characters.forEach(c => { c.isActive = false; c.isNext = false; });
            updateTurnDisplay();
            updateInitiativeList();
            updateActiveCharacter();
            updateSummary();
            addLogEntry('Combate resetado pelo usuário', 'turn');
            playSoundEffect('reset');
        }

        // SIMULAR EFEITOS SONOROS
        function playSoundEffect(type) {
            // Em uma implementação real, você tocaria arquivos de áudio
            console.log(`Som reproduzido: ${type}`);
        }

        // INICIAR QUANDO A PÁGINA CARREGAR
        window.onload = function() {
            initCombat();
            // Tentar carregar itens da ficha ao iniciar
            loadItemsFromSheet();
        };

        // CARREGAR PERSONAGENS DO LOCAL STORAGE
        function loadCharacters() {
            const characters = JSON.parse(localStorage.getItem('characters')) || [];
            const characterList = document.getElementById('character-list');
            characterList.innerHTML = '';

            characters.forEach((character, index) => {
                const characterItem = document.createElement('div');
                characterItem.innerHTML = `
                    <p><strong>${character.name}</strong> - Nível: ${character.level}</p>
                    <button onclick="removeCharacter(${index})">Remover</button>
                `;
                characterList.appendChild(characterItem);
            });
        }

        // REMOVER PERSONAGEM DO LOCAL STORAGE
        function removeCharacter(index) {
            const characters = JSON.parse(localStorage.getItem('characters')) || [];
            characters.splice(index, 1);
            localStorage.setItem('characters', JSON.stringify(characters));
            loadCharacters();
        }

        document.addEventListener('DOMContentLoaded', loadCharacters);

        // Ouvir atualizações vindas de outras abas (ex.: página de criação salvou no sheetRepo)
        window.addEventListener('storage', function(e) {
            if (!e.key) return;
            if (e.key === 'sheetRepoUpdated') {
                try {
                    const payload = JSON.parse(e.newValue || '{}');
                    console.log('sheetRepoUpdated recebido:', payload);
                } catch (err) {
                    console.log('sheetRepoUpdated recebido (não JSON)');
                }
                // Abre o modal de adição automaticamente
                openAddModal();

                // destacar (visual) a ficha recém-criada no modal, se possível
                setTimeout(() => {
                    try {
                        const raw = localStorage.getItem('sheetRepoUpdated');
                        const info = raw ? JSON.parse(raw) : null;
                        if (info && info.sheetId) {
                            const modal = document.querySelector('.sheet-modal');
                            if (modal) {
                                const btn = modal.querySelector(`button[onclick="addCharFromSheet('${info.sheetId}')"]`);
                                if (btn) {
                                    btn.style.boxShadow = '0 0 14px rgba(52,199,89,0.9)';
                                    btn.style.transform = 'translateY(-2px)';
                                    setTimeout(()=>{ btn.style.boxShadow=''; btn.style.transform=''; }, 2500);
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Erro ao destacar ficha recém-criada:', e);
                    }
                }, 300);
            }
            // Sincronizar itens quando atualizados da ficha
            else if (e.key === 'itemsUpdated') {
                loadItemsFromSheet();
            }
        });

// REMOVER PERSONAGEM DA ORDEM DE COMBATE (por id)
function removeCombatCharacter(id) {
    const idx = combatData.characters.findIndex(c => c.id === id);
    if (idx === -1) return;

            const removed = combatData.characters.splice(idx, 1)[0];
            addLogEntry(`<strong>${removed.name}</strong> foi removido da ordem de iniciativa`);

            // Se não houver mais personagens, resetar estado ativo
            if (combatData.characters.length === 0) {
                combatData.currentTurn = 0;
                combatData.rounds = 0;
            }

            updateInitiativeList();
            updateActiveCharacter();
            updateTurnDisplay();
        }

        // AJUSTAR VALOR DE STAT (PV ou CO)
        function adjustStat(statType, amount) {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) return;

            // Inicializar controle de mudanças se não existir
            if (!statChanges[activeChar.id]) {
                statChanges[activeChar.id] = { hp: 0, co: 0 };
            }

            if (statType === 'hp') {
                const newHp = Math.max(0, Math.min(activeChar.maxHp, activeChar.hp + amount));
                activeChar.hp = newHp;
                statChanges[activeChar.id].hp += amount;
            } else if (statType === 'co') {
                const newCo = Math.max(0, Math.min(activeChar.maxCo, activeChar.co + amount));
                activeChar.co = newCo;
                statChanges[activeChar.id].co += amount;
            }

            updateActiveCharacter();
            updateInitiativeList();
        }

        // EDITAR VALOR DE STAT (clicando no texto)
        function editStat(statType) {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) return;

            const currentValue = statType === 'hp' ? activeChar.hp : activeChar.co;
            const maxValue = statType === 'hp' ? activeChar.maxHp : activeChar.maxCo;
            const statName = statType === 'hp' ? 'PV' : 'CO';
            const textElement = document.getElementById(statType + 'Text');

            // Criar input inline
            const input = document.createElement('input');
            input.type = 'number';
            input.min = '0';
            input.max = maxValue;
            input.value = currentValue;
            input.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-family: 'Orbitron', sans-serif;
                font-weight: 700;
                font-size: 0.9rem;
                color: white;
                background: rgba(0, 0, 0, 0.8);
                border: 2px solid var(--hexa-blue);
                border-radius: 4px;
                padding: 2px 8px;
                width: 80px;
                text-align: center;
                z-index: 20;
            `;

            // Substituir texto pelo input
            textElement.style.display = 'none';
            textElement.parentNode.appendChild(input);
            input.focus();
            input.select();

            // Função para salvar ou cancelar
            const saveOrCancel = () => {
                const newValue = parseInt(input.value);
                
                if (!isNaN(newValue) && newValue >= 0 && newValue <= maxValue) {
                    // Inicializar controle de mudanças se não existir
                    if (!statChanges[activeChar.id]) {
                        statChanges[activeChar.id] = { hp: 0, co: 0 };
                    }

                    const oldValue = currentValue;
                    const difference = newValue - oldValue;
                    
                    if (statType === 'hp') {
                        activeChar.hp = newValue;
                        statChanges[activeChar.id].hp += difference;
                    } else {
                        activeChar.co = newValue;
                        statChanges[activeChar.id].co += difference;
                    }
                    
                    updateActiveCharacter();
                    updateInitiativeList();
                }
                
                // Remover input e mostrar texto novamente
                input.remove();
                textElement.style.display = '';
            };

            // Eventos
            input.addEventListener('blur', saveOrCancel);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveOrCancel();
                } else if (e.key === 'Escape') {
                    input.remove();
                    textElement.style.display = '';
                }
            });
        }

        // REGISTRAR MUDANÇAS DE STATS NO LOG (chamado no final do turno)
        function logStatChanges() {
            Object.keys(statChanges).forEach(charId => {
                const char = combatData.characters.find(c => c.id == charId);
                if (!char) return;

                const changes = statChanges[charId];
                let logMessages = [];

                if (changes.hp !== 0) {
                    const action = changes.hp > 0 ? 'recebeu' : 'perdeu';
                    logMessages.push(`${action} ${Math.abs(changes.hp)} PV`);
                }

                if (changes.co !== 0) {
                    const action = changes.co > 0 ? 'ganhou' : 'perdeu';
                    logMessages.push(`${action} ${Math.abs(changes.co)} CO`);
                }

                if (logMessages.length > 0) {
                    addLogEntry(`${char.name} ${logMessages.join(' e ')} neste turno`, 
                               changes.hp > 0 ? 'heal' : 'damage');
                }
            });

            // Resetar mudanças após o log
            statChanges = {};
        }

        // SIMULAR EFEITOS SONOROS
        function playSoundEffect(type) {
            // Em uma implementação real, você tocaria arquivos de áudio
            console.log(`Som reproduzido: ${type}`);
        }

        // setup do toggle de protocolos (colapsar/expandir)
        function setupProtocolsToggle() {
            const toggle = document.getElementById('protocolsToggle');
            const list = document.getElementById('protocolsList');
            const arrow = document.getElementById('protocolsArrow');
            if (!toggle || !list) return;
            toggle.addEventListener('click', () => {
                const expanded = list.style.display === 'block';
                if (expanded) {
                    list.style.display = 'none';
                    if (arrow) arrow.textContent = '›';
                    list.setAttribute('aria-hidden', 'true');
                } else {
                    list.style.display = 'block';
                    if (arrow) arrow.textContent = '˅';
                    list.setAttribute('aria-hidden', 'false');
                }
            });
        }
    </script>

    <!-- duplicata removida: #character-list já está dentro da sidebar -->
</body>