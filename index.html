<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HEXA - Painel de Combate</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --cyber-black: #000000;
            --primary-1: #FB00C1;
            --primary-2: #85FFC6;
            --secondary: #7332FE;
            --cyber-white: #FFFFFF;
            --cyber-gray: #1A1A1A;
            --cyber-blue: #00D4FF;
            --cyber-yellow: #FFD700;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--cyber-black);
            color: var(--cyber-white);
            font-family: 'Orbitron', monospace;
            min-height: 100vh;
            overflow-y: auto;
            position: relative;
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(133, 255, 198, 0.03) 2px,
                rgba(133, 255, 198, 0.03) 4px
            );
            pointer-events: none;
            z-index: 1;
        }

        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 2px,
                    rgba(251, 0, 193, 0.02) 2px,
                    rgba(251, 0, 193, 0.02) 4px
                );
            pointer-events: none;
            z-index: 1;
            animation: scanlines 8s linear infinite;
        }

        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(10px); }
        }

        /* SCROLLBAR PERSONALIZADA CYBERPUNK */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: var(--cyber-black);
            border: 2px solid var(--primary-2);
            clip-path: polygon(5px 0, 100% 0, calc(100% - 5px) 100%, 0 100%);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-2);
            border: 2px solid var(--primary-1);
            clip-path: polygon(3px 0, 100% 0, calc(100% - 3px) 100%, 0 100%);
            transition: all 0.3s;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-1);
            border-color: var(--primary-2);
            box-shadow: 0 0 10px rgba(255, 229, 0, 0.5);
        }

        ::-webkit-scrollbar-corner {
            background: var(--cyber-black);
        }

        /* GLITCH EFFECT PERSONA 5 STYLE */
        .glitch {
            position: relative;
            animation: glitch-main 2s infinite;
        }

        .glitch::before,
        .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .glitch::before {
            left: 2px;
            text-shadow: -2px 0 var(--primary-2);
            clip: rect(24px, 550px, 90px, 0);
            animation: glitch-anim 3s infinite linear alternate-reverse;
        }

        .glitch::after {
            left: -2px;
            text-shadow: -2px 0 var(--primary-1);
            clip: rect(85px, 550px, 140px, 0);
            animation: glitch-anim2 2.5s infinite linear alternate-reverse;
        }

        @keyframes glitch-main {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-1px, 1px); }
            40% { transform: translate(-1px, -1px); }
            60% { transform: translate(1px, 1px); }
            80% { transform: translate(1px, -1px); }
        }

        @keyframes glitch-anim {
            0% { clip: rect(42px, 9999px, 44px, 0); }
            5% { clip: rect(12px, 9999px, 59px, 0); }
            10% { clip: rect(48px, 9999px, 29px, 0); }
            15% { clip: rect(42px, 9999px, 73px, 0); }
            20% { clip: rect(63px, 9999px, 27px, 0); }
            25% { clip: rect(34px, 9999px, 55px, 0); }
            30% { clip: rect(86px, 9999px, 73px, 0); }
            35% { clip: rect(20px, 9999px, 20px, 0); }
            40% { clip: rect(26px, 9999px, 60px, 0); }
            45% { clip: rect(25px, 9999px, 66px, 0); }
            50% { clip: rect(57px, 9999px, 98px, 0); }
            55% { clip: rect(5px, 9999px, 46px, 0); }
            60% { clip: rect(82px, 9999px, 31px, 0); }
            65% { clip: rect(54px, 9999px, 27px, 0); }
            70% { clip: rect(28px, 9999px, 99px, 0); }
            75% { clip: rect(45px, 9999px, 69px, 0); }
            80% { clip: rect(23px, 9999px, 85px, 0); }
            85% { clip: rect(54px, 9999px, 84px, 0); }
            90% { clip: rect(45px, 9999px, 47px, 0); }
            95% { clip: rect(37px, 9999px, 99px, 0); }
            100% { clip: rect(4px, 9999px, 43px, 0); }
        }

        @keyframes glitch-anim2 {
            0% { clip: rect(65px, 9999px, 100px, 0); }
            5% { clip: rect(52px, 9999px, 74px, 0); }
            10% { clip: rect(79px, 9999px, 85px, 0); }
            15% { clip: rect(75px, 9999px, 5px, 0); }
            20% { clip: rect(67px, 9999px, 61px, 0); }
            25% { clip: rect(14px, 9999px, 79px, 0); }
            30% { clip: rect(1px, 9999px, 66px, 0); }
            35% { clip: rect(86px, 9999px, 30px, 0); }
            40% { clip: rect(23px, 9999px, 98px, 0); }
            45% { clip: rect(85px, 9999px, 72px, 0); }
            50% { clip: rect(71px, 9999px, 75px, 0); }
            55% { clip: rect(2px, 9999px, 48px, 0); }
            60% { clip: rect(30px, 9999px, 16px, 0); }
            65% { clip: rect(59px, 9999px, 50px, 0); }
            70% { clip: rect(41px, 9999px, 62px, 0); }
            75% { clip: rect(2px, 9999px, 82px, 0); }
            80% { clip: rect(47px, 9999px, 73px, 0); }
            85% { clip: rect(3px, 9999px, 27px, 0); }
            90% { clip: rect(40px, 9999px, 86px, 0); }
            95% { clip: rect(45px, 9999px, 72px, 0); }
            100% { clip: rect(23px, 9999px, 49px, 0); }
        }

        /* CONTAINER PRINCIPAL */
        .combat-container {
            display: grid;
            grid-template-columns: 1fr 300px;
            grid-template-rows: 100px 1fr 120px;
            min-height: 100vh;
            height: auto;
            gap: 15px;
            padding: 20px;
        }

        /* HEADER */
        .header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--cyber-black);
            border: 3px solid var(--primary-1);
            padding: 0 30px;
            position: relative;
            overflow: hidden;
            clip-path: polygon(0 0, calc(100% - 20px) 0, 100% 100%, 20px 100%, 0 100%);
            box-shadow: 
                0 0 20px rgba(251, 0, 193, 0.5),
                inset 0 0 20px rgba(133, 255, 198, 0.1);
        }

        .header::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary-1), var(--primary-2), var(--primary-1));
            animation: glow-pulse 2s ease-in-out infinite;
        }

        @keyframes glow-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            font-weight: 900;
            letter-spacing: 3px;
            text-transform: uppercase;
            position: relative;
        }

        .logo-hexa {
            color: var(--primary-2);
            text-shadow: 
                0 0 10px rgba(133, 255, 198, 0.8),
                0 0 20px rgba(133, 255, 198, 0.4),
                2px 2px 0 var(--cyber-yellow);
            animation: logo-glitch 4s infinite;
        }

        .logo-supernova {
            color: var(--primary-1);
            text-shadow: 
                0 0 10px rgba(251, 0, 193, 0.8),
                0 0 20px rgba(251, 0, 193, 0.4),
                -2px -2px 0 var(--cyber-blue);
        }

        @keyframes logo-glitch {
            0%, 100% { transform: translate(0); }
            10% { transform: translate(-2px, 2px); }
            20% { transform: translate(2px, -2px); }
            30% { transform: translate(-2px, -2px); }
            40% { transform: translate(2px, 2px); }
            50% { transform: translate(0); }
        }

        .turn-display {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 15px;
        }

        .turn-number {
            font-family: 'Orbitron', sans-serif;
            font-size: 3.5rem;
            color: var(--primary-1);
            text-shadow: 
                0 0 15px rgba(255, 229, 0, 0.8),
                0 0 25px rgba(255, 229, 0, 0.4),
                2px 2px 0 var(--cyber-blue);
            line-height: 1;
            animation: number-flicker 3s infinite;
        }

        @keyframes number-flicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.8; }
            94% { opacity: 1; }
            96% { opacity: 0.9; }
            97% { opacity: 1; }
        }

        .turn-label {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.8rem;
            letter-spacing: 2px;
            color: var(--cyber-white);
            text-shadow: 0 0 5px rgba(0, 212, 255, 0.5);
        }

        .combat-time {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: var(--primary-2);
            background: var(--cyber-black);
            padding: 8px 15px;
            border: 2px solid var(--primary-2);
            clip-path: polygon(10px 0, 100% 0, calc(100% - 10px) 100%, 0 100%);
            box-shadow: 
                0 0 10px rgba(0, 212, 255, 0.5),
                inset 0 0 10px rgba(0, 212, 255, 0.1);
            animation: time-pulse 2s infinite;
        }

        @keyframes time-pulse {
            0%, 100% { border-color: var(--secondary); }
            50% { border-color: var(--primary-1); }
        }

        /* ÁREA PRINCIPAL */
        .main-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        /* CARTÃO DO PERSONAGEM ATIVO */
        .active-character {
            background: var(--cyber-black);
            border: 3px solid var(--primary-1);
            padding: 25px;
            position: relative;
            overflow: hidden;
            clip-path: polygon(0 0, calc(100% - 15px) 0, 100% 15px, 100% 100%, 15px 100%, 0 calc(100% - 15px));
            box-shadow: 
                0 0 30px rgba(255, 229, 0, 0.4),
                inset 0 0 30px rgba(0, 212, 255, 0.1);
        }

        .active-character::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, var(--primary-1), var(--primary-2), var(--primary-1));
            animation: border-glow 3s ease-in-out infinite;
        }

        @keyframes border-glow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .character-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 25px;
        }

        .character-avatar {
            width: 120px;
            height: 120px;
            border: 3px solid var(--secondary);
            overflow: hidden;
            background: var(--cyber-black);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            clip-path: polygon(20px 0, 100% 0, calc(100% - 20px) 100%, 0 100%);
            box-shadow: 0 0 20px rgba(115, 50, 254, 0.5);
        }

        .character-info h2 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2.8rem;
            letter-spacing: 2px;
            color: var(--cyber-white);
            margin-bottom: 5px;
            text-shadow: 
                0 0 10px rgba(0, 212, 255, 0.5),
                2px 2px 0 var(--cyber-yellow);
            animation: name-glitch 5s infinite;
        }

        @keyframes name-glitch {
            0%, 100% { transform: translate(0); }
            2% { transform: translate(-1px, 1px); }
            4% { transform: translate(1px, -1px); }
            6% { transform: translate(0); }
        }

        .character-archetype {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary-2);
            font-size: 1.2rem;
            margin-bottom: 10px;
            text-shadow: 0 0 5px rgba(0, 212, 255, 0.5);
        }

        /* BARRAS DE STATUS */
        .status-bars {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
        }

        .bar-container {
            display: flex;
            align-items: center;
            gap: 15px;
            width: 100%;
        }

        .bar-label {
            width: 60px;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            letter-spacing: 1px;
            color: var(--cyber-white);
            text-shadow: 0 0 5px rgba(0, 212, 255, 0.5);
        }

        .bar {
            position: relative;
            height: 28px;
            background: rgba(255, 255, 255, 0.1);
            overflow: hidden;
            margin-bottom: 5px;
            flex: 1;
            min-width: 200px;
            border: 1px solid var(--secondary);
            clip-path: polygon(5px 0, 100% 0, calc(100% - 5px) 100%, 0 100%);
        }

        .bar-fill {
            height: 100%;
            transition: width 0.5s ease;
            position: relative;
        }

        .bar-fill::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: bar-shine 3s infinite;
        }

        @keyframes bar-shine {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }

        .hp-bar .bar-fill {
            background: linear-gradient(90deg, var(--primary-1), #FF4081);
            box-shadow: 0 0 10px rgba(251, 0, 193, 0.5);
        }

        .co-bar .bar-fill {
            background: linear-gradient(90deg, var(--secondary), #9B59FF);
            box-shadow: 0 0 10px rgba(115, 50, 254, 0.5);
        }

        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 0.9rem;
            color: white;
            cursor: pointer;
            padding: 2px 8px;
            border-radius: 4px;
            transition: background 0.3s;
            z-index: 10;
        }

        .bar-text:hover {
            background: rgba(0, 0, 0, 0.5);
        }

        .bar-adjust-buttons {
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            gap: 2px;
            z-index: 15;
        }

        .bar-adjust-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-weight: bold;
        }

        .bar-adjust-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .bar-adjust-btn:active {
            transform: scale(0.9);
        }

        /* STATUS EFEITOS */
        .status-effects {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 25px;
        }

        /* Protocolos collapsible dentro do cartão ativo */
        .protocols-container {
            margin-top: 8px;
        }

        .protocols-toggle {
            background: transparent;
            border: none;
            color: var(--hexa-white);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.05rem;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .protocols-list {
            margin-top: 10px;
            display: none;
            max-height: 120px; /* limita a altura e permite scroll */
            overflow-y: auto;
            padding-right: 6px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .protocols-list .effect-tag {
            padding: 4px 10px;
            font-size: 0.85rem;
        }

        .effect-tag {
            background: rgba(0, 122, 255, 0.2);
            border: 1px solid var(--secondary);
            border-radius: 20px;
            padding: 5px 15px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .effect-tag.positive {
            background: rgba(52, 199, 89, 0.2);
            border-color: var(--hexa-green);
        }

        .effect-tag.negative {
            background: rgba(255, 59, 48, 0.2);
            border-color: var(--hexa-red);
        }

        /* AÇÕES RÁPIDAS */
        .quick-actions {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .action-btn {
            background: var(--cyber-black);
            border: 2px solid var(--primary-1);
            color: var(--primary-1);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.4rem;
            letter-spacing: 1px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            text-transform: uppercase;
            clip-path: polygon(10px 0, 100% 0, calc(100% - 10px) 100%, 0 100%);
            position: relative;
            overflow: hidden;
        }

        .action-btn::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(115, 50, 254, 0.3), transparent);
            transition: left 0.5s;
        }

        .action-btn:hover::before {
            left: 100%;
        }

        .action-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 
                0 5px 20px rgba(115, 50, 254, 0.6),
                inset 0 0 20px rgba(115, 50, 254, 0.1);
            border-color: var(--primary-2);
            color: var(--primary-2);
        }

        .action-btn:active {
            transform: translateY(-1px) scale(1.02);
        }

        .action-btn.blue {
            border-color: var(--primary-2);
            color: var(--primary-2);
        }

        .action-btn.blue::before {
            background: linear-gradient(90deg, transparent, rgba(115, 50, 254, 0.3), transparent);
        }

        .action-btn.blue:hover {
            box-shadow: 
                0 5px 20px rgba(115, 50, 254, 0.6),
                inset 0 0 20px rgba(115, 50, 254, 0.1);
            border-color: var(--primary-1);
            color: var(--primary-1);
        }

        .action-btn.yellow {
            border-color: var(--primary-1);
            color: var(--primary-1);
        }

        .action-btn.yellow::before {
            background: linear-gradient(90deg, transparent, rgba(255, 229, 0, 0.3), transparent);
        }

        .action-btn.yellow:hover {
            box-shadow: 
                0 5px 20px rgba(255, 229, 0, 0.6),
                inset 0 0 20px rgba(255, 229, 0, 0.1);
            border-color: var(--primary-2);
            color: var(--primary-2);
        }

        .action-btn.purple {
            border-color: var(--secondary);
            color: var(--secondary);
        }

        .action-btn.purple::before {
            background: linear-gradient(90deg, transparent, rgba(0, 212, 255, 0.3), transparent);
        }

        .action-btn.purple:hover {
            box-shadow: 
                0 5px 20px rgba(0, 212, 255, 0.6),
                inset 0 0 20px rgba(0, 212, 255, 0.1);
            border-color: var(--primary-1);
            color: var(--primary-1);
        }

        .action-btn.green {
            border-color: var(--secondary);
            color: var(--secondary);
        }

        .action-btn.green::before {
            background: linear-gradient(90deg, transparent, rgba(255, 229, 0, 0.3), transparent);
        }

        .action-btn.green:hover {
            box-shadow: 
                0 5px 20px rgba(255, 229, 0, 0.6),
                inset 0 0 20px rgba(255, 229, 0, 0.1);
            border-color: var(--primary-1);
            color: var(--primary-1);
        }

        /* LOG DE AÇÕES */
        .action-log {
            background: var(--cyber-black);
            padding: 20px;
            border: 2px solid var(--primary-2);
            overflow: hidden;
            clip-path: polygon(0 0, calc(100% - 15px) 0, 100% 15px, 100% 100%, 15px 100%, 0 calc(100% - 15px));
            box-shadow: 
                0 0 20px rgba(0, 212, 255, 0.3),
                inset 0 0 20px rgba(0, 212, 255, 0.05);
        }

        .log-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.8rem;
            letter-spacing: 1px;
            margin-bottom: 15px;
            color: var(--primary-2);
            display: flex;
            align-items: center;
            gap: 10px;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .log-content {
            height: 300px;
            overflow-y: auto;
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            color: var(--cyber-white);
        }

        .log-content::-webkit-scrollbar {
            width: 8px;
        }

        .log-content::-webkit-scrollbar-track {
            background: var(--cyber-black);
            border: 1px solid var(--secondary);
        }

        .log-content::-webkit-scrollbar-thumb {
            background: var(--primary-2);
            border: 1px solid var(--secondary);
        }

        .log-content::-webkit-scrollbar-thumb:hover {
            background: var(--primary-1);
        }

        .log-entry {
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid var(--hexa-yellow);
        }

        .log-entry.turn {
            border-left-color: var(--hexa-yellow);
            background: rgba(255, 204, 0, 0.1);
        }

        .log-entry.damage {
            border-left-color: var(--hexa-red);
            background: rgba(255, 59, 48, 0.1);
        }

        .log-entry.heal {
            border-left-color: var(--hexa-green);
            background: rgba(52, 199, 89, 0.1);
        }

        /* BARRA LATERAL - ORDEM DE INICIATIVA */
        .initiative-sidebar {
            grid-row: 2;
            grid-column: 2;
            background: var(--cyber-black);
            padding: 20px;
            border: 2px solid var(--primary-2);
            overflow-y: auto;
            clip-path: polygon(0 0, calc(100% - 15px) 0, 100% 15px, 100% 100%, 15px 100%, 0 calc(100% - 15px));
            box-shadow: 
                0 0 20px rgba(0, 212, 255, 0.3),
                inset 0 0 20px rgba(0, 212, 255, 0.05);
        }

        .initiative-sidebar::-webkit-scrollbar {
            width: 8px;
        }

        .initiative-sidebar::-webkit-scrollbar-track {
            background: var(--cyber-black);
            border: 1px solid var(--secondary);
        }

        .initiative-sidebar::-webkit-scrollbar-thumb {
            background: var(--primary-2);
            border: 1px solid var(--secondary);
        }

        .initiative-sidebar::-webkit-scrollbar-thumb:hover {
            background: var(--primary-1);
        }

        .sidebar-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2rem;
            letter-spacing: 2px;
            margin-bottom: 20px;
            color: var(--primary-2);
            text-align: center;
            border-bottom: 2px solid var(--secondary);
            padding-bottom: 10px;
            text-shadow: 0 0 10px rgba(115, 50, 254, 0.5);
        }

        .initiative-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .initiative-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            border: 2px solid transparent;
            transition: all 0.3s;
            clip-path: polygon(5px 0, 100% 0, calc(100% - 5px) 100%, 0 100%);
        }

        .initiative-item:hover {
            transform: translateX(5px);
            border-color: var(--primary-2);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .initiative-item.active {
            border-color: var(--primary-1);
            background: rgba(255, 229, 0, 0.1);
            box-shadow: 0 0 20px rgba(255, 229, 0, 0.4);
            animation: active-pulse 2s infinite;
        }

        @keyframes active-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .initiative-item.next {
            border-color: var(--primary-2);
            background: rgba(0, 212, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .initiative-avatar {
            width: 50px;
            height: 50px;
            border: 2px solid var(--primary-2);
            background: var(--cyber-black);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            clip-path: polygon(10px 0, 100% 0, calc(100% - 10px) 100%, 0 100%);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }

        .initiative-info {
            flex: 1;
        }

        .initiative-name {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.4rem;
            letter-spacing: 1px;
        }

        .initiative-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
        }

        .initiative-value {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            color: var(--primary-1);
            background: var(--cyber-black);
            padding: 3px 10px;
            border: 1px solid var(--secondary);
            font-size: 1.1rem;
            min-width: 40px;
            text-align: center;
            clip-path: polygon(3px 0, 100% 0, calc(100% - 3px) 100%, 0 100%);
            box-shadow: 0 0 10px rgba(115, 50, 254, 0.3);
        }

        /* FOOTER */
        .footer {
            grid-column: 1 / -1;
            background: var(--cyber-black);
            padding: 20px;
            border: 2px solid var(--primary-2);
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            clip-path: polygon(0 0, calc(100% - 20px) 0, 100% 100%, 20px 100%, 0 100%);
            box-shadow: 
                0 0 20px rgba(0, 212, 255, 0.3),
                inset 0 0 20px rgba(0, 212, 255, 0.05);
        }

        .turn-summary {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .summary-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            letter-spacing: 1px;
            color: var(--primary-2);
            text-shadow: 0 0 5px rgba(0, 212, 255, 0.5);
        }

        .summary-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            color: var(--primary-1);
            text-shadow: 0 0 10px rgba(255, 229, 0, 0.5);
        }

        .control-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .control-btn {
            background: var(--cyber-black);
            border: 2px solid var(--primary-1);
            color: var(--primary-1);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            letter-spacing: 1px;
            padding: 12px 20px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 150px;
            text-transform: uppercase;
            clip-path: polygon(10px 0, 100% 0, calc(100% - 10px) 100%, 0 100%);
            position: relative;
            overflow: hidden;
        }

        .control-btn::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(115, 50, 254, 0.3), transparent);
            transition: left 0.5s;
        }

        .control-btn:hover::before {
            left: 100%;
        }

        .control-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 
                0 5px 20px rgba(115, 50, 254, 0.6),
                inset 0 0 20px rgba(115, 50, 254, 0.1);
            border-color: var(--primary-2);
            color: var(--primary-2);
        }

        .control-btn:active {
            transform: translateY(-1px) scale(1.02);
        }

        .control-btn.blue {
            border-color: var(--secondary);
            color: var(--secondary);
        }

        .control-btn.blue::before {
            background: linear-gradient(90deg, transparent, rgba(0, 212, 255, 0.3), transparent);
        }

        .control-btn.blue:hover {
            box-shadow: 
                0 5px 20px rgba(0, 212, 255, 0.6),
                inset 0 0 20px rgba(0, 212, 255, 0.1);
            border-color: var(--secondary);
            color: var(--secondary);
        }

        /* ESTILOS PARA SEÇÃO DE ITENS */
        .item-actions {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .items-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .item-card {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s;
        }

        .item-card:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-2px);
        }

        .item-info {
            flex: 1;
        }

        .item-name {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            color: var(--hexa-white);
            margin-bottom: 4px;
        }

        .item-effect {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 4px;
        }

        .item-details {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
        }

        .item-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .item-btn {
            background: linear-gradient(145deg, rgba(0, 122, 255, 0.9), rgba(0, 90, 200, 0.9));
            border: none;
            border-radius: 6px;
            color: white;
            padding: 6px 12px;
            cursor: pointer;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .item-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(0, 122, 255, 0.4);
        }

        .item-btn.use {
            background: linear-gradient(145deg, var(--hexa-green), #28a745);
        }

        .item-btn.use:hover {
            box-shadow: 0 3px 10px rgba(52, 199, 89, 0.4);
        }

        .empty-items {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            padding: 20px;
        }

        /* MODAL PARA ADICIONAR ITENS */
        .item-modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .item-modal {
            background: linear-gradient(145deg, #1a1a1a, #0f0f0f);
            border: 2px solid var(--hexa-green);
            padding: 25px;
            border-radius: 15px;
            width: 450px;
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
        }

        .item-modal h3 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.8rem;
            color: var(--hexa-green);
            margin-bottom: 20px;
            text-align: center;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            color: var(--hexa-white);
            margin-bottom: 5px;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 10px;
            color: var(--hexa-white);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--hexa-green);
            box-shadow: 0 0 10px rgba(52, 199, 89, 0.3);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 60px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .modal-btn {
            background: linear-gradient(145deg, var(--hexa-green), #28a745);
            border: none;
            border-radius: 8px;
            color: white;
            padding: 10px 20px;
            cursor: pointer;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1rem;
            transition: all 0.3s;
        }

            .modal-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(52, 199, 89, 0.4);
            }

            .modal-btn.cancel {
                background: linear-gradient(145deg, var(--hexa-red), #dc3545);
            }

            .modal-btn.cancel:hover {
                box-shadow: 0 5px 15px rgba(255, 59, 48, 0.4);
            }

            /* ESTILOS PARA MODAL DE SELEÇÃO DE ALVO */
            .targets-list {
                display: flex;
                flex-direction: column;
                gap: 10px;
                max-height: 300px;
                overflow-y: auto;
                margin-bottom: 20px;
            }

            .target-item {
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                padding: 12px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                transition: all 0.3s;
                cursor: pointer;
            }

            .target-item:hover {
                background: rgba(255, 255, 255, 0.12);
                transform: translateY(-2px);
                border-color: var(--hexa-green);
            }

            .target-item.active {
                background: rgba(52, 199, 89, 0.1);
                border-color: var(--hexa-green);
                box-shadow: 0 0 15px rgba(52, 199, 89, 0.3);
            }

            .target-info {
                flex: 1;
            }

            .target-name {
                font-family: 'Bebas Neue', sans-serif;
                font-size: 1.1rem;
                color: var(--hexa-white);
                margin-bottom: 4px;
            }

            .target-stats {
                font-size: 0.85rem;
                color: rgba(255, 255, 255, 0.7);
                margin-bottom: 4px;
            }

            .target-avatar {
                width: 40px;
                height: 40px;
                border-radius: 8px;
                border: 2px solid var(--hexa-blue);
                background: linear-gradient(45deg, #1a1a1a, #333);
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.2rem;
            }

        /* Modal para repositório de fichas */
        .sheet-modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .sheet-modal {
            background: #0f0f0f;
            border: 2px solid var(--hexa-purple);
            padding: 20px;
            border-radius: 12px;
            width: 420px;
            max-height: 70vh;
            overflow-y: auto;
        }
        .sheet-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            background: rgba(255,255,255,0.03);
        }
        .sheet-item button {
            background: linear-gradient(145deg, rgba(0,122,255,0.9), rgba(0,90,200,0.9));
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
        }

        /* LISTA DE PERSONAGENS (CARREGADA DO LOCAL STORAGE) */
        #character-list {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 12px;
            border: 2px solid var(--hexa-purple);
        }

        #character-list p {
            margin: 0;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            color: var(--hexa-white);
        }

        #character-list button {
            background: var(--hexa-red);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1rem;
            margin-top: 10px;
            transition: background 0.3s;
        }

        #character-list button:hover {
            background: #c62828;
        }
    </style>
</head>
<body>
    <div class="combat-container">
        <!-- HEADER -->
        <header class="header">
            <div class="logo">
                <span class="logo-hexa glitch" data-text="H.E.X.A">H.E.X.A</span> 
                <span class="logo-supernova"></span>
            </div>
            
            <div class="turn-display">
                <div class="turn-label">RODADAS</div>
                <div class="turn-number" id="roundsDisplay" style="font-size:1.2rem;">00</div>
                <div class="turn-label" style="font-size:0.9rem; margin-left:10px;">TURNO</div>
                <div class="turn-number" id="currentTurn" style="font-size:0.9rem; margin-left:5px;">00</div>
            </div>
            
            <div class="combat-time">
                <i class="fas fa-clock"></i> <span id="combatTimer">00:00</span>
            </div>
        </header>
        
        <!-- ÁREA PRINCIPAL -->
        <main class="main-area">
            <!-- CARTÃO DO PERSONAGEM ATIVO -->
            <section class="active-character">
                <div class="character-header">
                    <div class="character-avatar">
                        <i class="fas fa-user-ninja"></i>
                    </div>
                        <div class="character-info">
                        <h2 id="activeCharacterName">ARISCO</h2>
                        <div class="character-archetype"></div>
                        <div class="character-status" id="characterStatus"></div>
                        <!-- sample status tags (hidden template for later use) -->
                        <template id="statusSample" style="display:none">
                            <span class="effect-tag positive"><i class="fas fa-bullseye"></i> VANTAGEM</span>
                            <span class="effect-tag positive"><i class="fas fa-shield-alt"></i> DEF +2</span>
                            <span class="effect-tag negative"><i class="fas fa-tint"></i> SANGRANDO</span>
                        </template>
                    </div>
                </div>
                
                <div class="status-bars">
                    <div class="bar-container">
                        <div class="bar-label">PV</div>
                        <div class="bar hp-bar">
                            <div class="bar-fill" id="hpBar" style="width: 75%"></div>
                            <div class="bar-text" id="hpText" onclick="editStat('hp')">45/60</div>
                            <div class="bar-adjust-buttons">
                                <button class="bar-adjust-btn" onclick="adjustStat('hp', -1)">−</button>
                                <button class="bar-adjust-btn" onclick="adjustStat('hp', 1)">+</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="bar-container">
                        <div class="bar-label">CO</div>
                        <div class="bar co-bar">
                            <div class="bar-fill" id="coBar" style="width: 53%"></div>
                            <div class="bar-text" id="coText" onclick="editStat('co')">8/15</div>
                            <div class="bar-adjust-buttons">
                                <button class="bar-adjust-btn" onclick="adjustStat('co', -1)">−</button>
                                <button class="bar-adjust-btn" onclick="adjustStat('co', 1)">+</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="status-effects" id="statusEffects"></div>
                
                <div class="quick-actions" id="quickActions">
                    <button class="action-btn" onclick="takeAction('attack')">
                        <i class="fas fa-fist-raised"></i> ATACAR
                    </button>
                    <button class="action-btn blue" onclick="toggleSkillButtons()">
                        <i class="fas fa-bolt"></i> HABILIDADE
                    </button>
                    <button class="action-btn yellow" onclick="takeAction('move')">
                        <i class="fas fa-running"></i> MOVER
                    </button>
                    <button class="action-btn" onclick="takeAction('item')">
                        <i class="fas fa-briefcase-medical"></i> ITEM
                    </button>
                </div>
                <div class="skill-actions" id="skillActions" style="display:none;">
                    <div class="items-list" id="skillsList">
                        <!-- Habilidades serão adicionadas dinamicamente aqui -->
                    </div>
                    <div class="item-controls">
                        <button class="action-btn purple" onclick="toggleSkillButtons()">
                            <i class="fas fa-arrow-left"></i> VOLTAR
                        </button>
                    </div>
                </div>
                <div class="item-actions" id="itemActions" style="display:none;">
                    <div class="items-list" id="itemsList">
                        <!-- Itens serão adicionados dinamicamente aqui -->
                    </div>
                    <div class="item-controls">
                        <button class="action-btn green" onclick="openAddItemModal()">
                            <i class="fas fa-plus"></i> ADICIONAR ITEM
                        </button>
                        <button class="action-btn purple" onclick="takeAction('item')">
                            <i class="fas fa-arrow-left"></i> VOLTAR
                        </button>
                    </div>
                </div>
                <div class="protocols-container">
                    <button id="protocolsToggle" class="protocols-toggle">Protocolos <span id="protocolsArrow">›</span></button>
                    <div id="protocolsList" class="protocols-list" aria-hidden="true"></div>
                </div>
            </section>
            
            <!-- LOG DE AÇÕES -->
            <section class="action-log">
                <div class="log-title">
                    <i class="fas fa-scroll"></i> LOG DE COMBATE
                </div>
                <div class="log-content" id="actionLog">
                    
                </div>
            </section>
        </main>
        
        <!-- BARRA LATERAL - ORDEM DE INICIATIVA -->
        <aside class="initiative-sidebar">
            <div class="sidebar-title">
                <i class="fas fa-list-ol"></i> ORDEM DE INICIATIVA
            </div>
            <div class="initiative-list" id="initiativeList">
                <!-- Itens serão gerados por JavaScript -->
            </div>
            <!-- Lista de fichas salvas / carregadas do localStorage -->
            <div id="character-list" style="margin-top:16px;"></div>
        </aside>
        
        <!-- FOOTER -->
        <footer class="footer">
            <div class="turn-summary">
                <div class="summary-title">DANO ESTE TURNO</div>
                <div class="summary-value" id="damageThisTurn">0</div>
            </div>
            
            <div class="turn-summary">
                <div class="summary-title">CO GASTO ESTE TURNO</div>
                <div class="summary-value" id="coSpentThisTurn">0</div>
            </div>
            
            <div class="control-buttons">
                <button class="control-btn" onclick="nextTurn()">
                    <i class="fas fa-forward"></i> PRÓXIMO TURNO
                </button>
                <button class="control-btn blue" onclick="rollInitiative()">
                    <i class="fas fa-dice-d20"></i> ROLAR INICIATIVA
                </button>
                    <button class="control-btn blue" onclick="window.open('pages/create_character.html','_blank')">
                        <i class="fas fa-file-circle-plus"></i> CRIAR FICHA
                    </button>
                <button class="control-btn" onclick="openAddModal()">
                    <i class="fas fa-user-plus"></i> ADICIONAR
                </button>
                <button class="control-btn" onclick="resetCombat()">
                    <i class="fas fa-undo"></i> RESETAR
                </button>
            </div>
        </footer>
    </div>

    <!-- MODAL DE FICHAS -->
    <div id="sheetModalContainer" style="display:none;"></div>

    <!-- MODAL PARA ADICIONAR ITENS -->
    <div id="itemModalContainer" style="display:none;"></div>

    <!-- BALÃO DE CRÍTICO (aparece quando necessário) -->
    <div class="critical-popup" id="criticalPopup" style="display: none;">
        <div> CRÍTICO! </div>
    </div>

    <script>
        // DADOS INICIAIS DO COMBATE (AGORA SEM NENHUM PERSONAGEM ATIVO)
        let combatData = {
            currentTurn: 0,
            rounds: 0,
            timer: 0, // segundos
            characters: [
                            ],
            damageThisTurn: 0,
            coSpentThisTurn: 0
        };

        // Sistema de controle de mudanças de stats por turno
        let statChanges = {};

        // REPOSITÓRIO DE FICHAS H.E.X.A
        const hexSheets = [
        ];

        // ADICIONAR ENTRADA NO LOG DE COMBATE
        function addLogEntry(message, type = 'turn') {
            const logContainer = document.getElementById('actionLog');
            if (!logContainer) return;
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.innerHTML = message;
            
            // Adicionar no início do log
            logContainer.insertBefore(logEntry, logContainer.firstChild);
            
            // Limitar número de entradas no log
            const maxEntries = 50;
            while (logContainer.children.length > maxEntries) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // INICIALIZAR A INTERFACE
        function initCombat() {
            updateTurnDisplay();
            updateInitiativeList();
            updateTimer();
            updateActiveCharacter();
            updateSummary();
            setupProtocolsToggle();
            
            // Iniciar timer
            setInterval(updateTimer, 1000);
        }

        // ATUALIZAR DISPLAY DO TURNO E RODADAS
        function updateTurnDisplay() {
            document.getElementById('currentTurn').textContent = combatData.currentTurn.toString().padStart(2, '0');
            document.getElementById('roundsDisplay').textContent = combatData.rounds.toString().padStart(2, '0');
        }

        // ATUALIZAR LISTA DE INICIATIVA
        function updateInitiativeList() {
            const list = document.getElementById('initiativeList');
            list.innerHTML = '';
            
            // Ordenar por iniciativa (maior primeiro)
            const sortedChars = [...combatData.characters].sort((a, b) => b.initiative - a.initiative);
            
            sortedChars.forEach(char => {
                const item = document.createElement('div');
                item.className = 'initiative-item';
                if (char.isActive) item.classList.add('active');
                if (char.isNext) item.classList.add('next');

                const hpPercent = Math.round((char.hp / char.maxHp) * 100);
                const coPercent = Math.round((char.co / char.maxCo) * 100);

                // Verificar se o personagem tem ID válido
                if (!char.id && char.id !== 0) {
                    console.error('Personagem sem ID válido:', char);
                    return;
                }

                item.innerHTML = `
                    <div class="initiative-avatar">${char.avatar}</div>
                    <div class="initiative-info">
                        <div class="initiative-name">${char.name}</div>
                        <div class="initiative-stats">
                            <span>HP: ${char.hp}/${char.maxHp}</span>
                            <span>CO: ${char.co}/${char.maxCo}</span>
                        </div>
                        <div class="progress-bar" style="height: 4px; background: rgba(255,255,255,0.1); margin-top: 5px; border-radius: 2px;">
                            <div style="height: 100%; width: ${hpPercent}%; background: ${hpPercent > 50 ? '#34C759' : hpPercent > 25 ? '#FF9500' : '#FF3B30'}; border-radius: 2px;"></div>
                        </div>
                    </div>
                    <div style="display:flex;flex-direction:column;align-items:center;gap:6px;">
                        <div class="initiative-value">${char.initiative}</div>
                        <button onclick="removeCombatCharacter('${char.id}')" style="background:var(--hexa-red);border:none;color:#fff;padding:6px 8px;border-radius:6px;cursor:pointer;font-family:'Bebas Neue';font-size:0.85rem;">Remover</button>
                    </div>
                `;

                list.appendChild(item);
            });
        }

        // ATUALIZAR PERSONAGEM ATIVO (AGORA MANUSEIA SEM ATIVO)
        function updateActiveCharacter() {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) {
                document.getElementById('activeCharacterName').textContent = 'NENHUM';
                document.getElementById('hpBar').style.width = `0%`;
                document.getElementById('hpText').textContent = `-/-`;
                document.getElementById('hpText').setAttribute('onclick', "editStat('hp')");
                document.getElementById('coBar').style.width = `0%`;
                document.getElementById('coText').textContent = `-/-`;
                document.getElementById('coText').setAttribute('onclick', "editStat('co')");
                return;
            }
            
            document.getElementById('activeCharacterName').textContent = activeChar.name;
            // atualizar texto do arquétipo dinamicamente
            const archeEl = document.querySelector('.character-archetype');
            if (archeEl) archeEl.textContent = activeChar.archetype || '';
            
            const hpPercent = Math.round((activeChar.hp / activeChar.maxHp) * 100);
            const coPercent = Math.round((activeChar.co / activeChar.maxCo) * 100);
            
            document.getElementById('hpBar').style.width = `${hpPercent}%`;
            document.getElementById('hpText').textContent = `${activeChar.hp}/${activeChar.maxHp}`;
            document.getElementById('hpText').setAttribute('onclick', "editStat('hp')");
            
            document.getElementById('coBar').style.width = `${coPercent}%`;
            document.getElementById('coText').textContent = `${activeChar.co}/${activeChar.maxCo}`;
            document.getElementById('coText').setAttribute('onclick', "editStat('co')");

            // Carregar itens pendentes se houver
            try {
                // Carregar itens específicos deste personagem
                const characterKey = `characterItems_${activeChar.id}`;
                const savedItems = localStorage.getItem(characterKey);
                
                if (savedItems) {
                    const items = JSON.parse(savedItems);
                    if (Array.isArray(items) && items.length > 0) {
                        if (!activeChar.inventory) {
                            activeChar.inventory = [];
                        }
                        activeChar.inventory = items;
                        updateItemsList();
                    }
                } else {
                    // Tentar carregar do characterInfo geral
                    const characterInfo = localStorage.getItem('characterItems');
                    if (characterInfo) {
                        const info = JSON.parse(characterInfo);
                        if (info.characterId === activeChar.id && Array.isArray(info.items)) {
                            if (!activeChar.inventory) {
                                activeChar.inventory = [];
                            }
                            activeChar.inventory = info.items;
                            updateItemsList();
                        }
                    }
                }
                
                // Limpar itens pendentes genéricos se existirem
                localStorage.removeItem('pendingItems');
            } catch(e) {
                console.error('Erro ao carregar itens pendentes:', e);
            }

            // Carregar habilidades do personagem
            try {
                const characterSkills = getCharacterSkills(activeChar.id);
                if (characterSkills && characterSkills.length > 0) {
                    updateSkillsList();
                }
            } catch(e) {
                console.error('Erro ao carregar habilidades do personagem:', e);
            }

            // Resetar visualização para os 4 botões originais ao mudar de personagem
            try {
                const quickActions = document.getElementById('quickActions');
                const itemActions = document.getElementById('itemActions');
                if (quickActions && itemActions) {
                    quickActions.style.display = 'grid';
                    itemActions.style.display = 'none';
                }
            } catch(e) {
                console.error('Erro ao resetar visualização de ações:', e);
            }

            // limpar status-effects visíveis (não mostrar exemplos estáticos)
            try { const se = document.getElementById('statusEffects'); if (se) se.innerHTML = ''; } catch(e){}

            // render protocolos (mostrar somente com 1+ pontos) dentro do container recolhível
            try{
                const protocolos = activeChar.protocolos || {};
                const protocolListEl = document.getElementById('protocolsList');
                if (protocolListEl) {
                    protocolListEl.innerHTML = '';
                    Object.entries(protocolos).forEach(([key, val]) => {
                        if (val && val > 0) {
                            const tag = document.createElement('span');
                            tag.className = 'effect-tag';
                            tag.textContent = `${key} +${val}`;
                            protocolListEl.appendChild(tag);
                        }
                    });
                }
            } catch(e){}
        }

        // ATUALIZAR TIMER
        function updateTimer() {
            combatData.timer++;
            const minutes = Math.floor(combatData.timer / 60);
            const seconds = combatData.timer % 60;
            document.getElementById('combatTimer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // ATUALIZAR RESUMO
        function updateSummary() {
            document.getElementById('damageThisTurn').textContent = combatData.damageThisTurn;
            document.getElementById('coSpentThisTurn').textContent = combatData.coSpentThisTurn;
        }

        // PRÓXIMO TURNO (AGORA GERA RODADAS AO ENROLAR)
        function nextTurn() {
            const currentIndex = combatData.characters.findIndex(c => c.isActive);
            const nextIndex = (currentIndex + 1) % combatData.characters.length;
            
            // Registrar mudanças de stats antes de mudar o turno
            logStatChanges();
            
            // Decrementar contadores de habilidades do personagem ativo atual
            decrementSkillTurns();
            
            // Resetar flags
            combatData.characters.forEach(c => {
                c.isActive = false;
                c.isNext = false;
            });
            
            // Se não há personagens, não fazer nada
            if (combatData.characters.length === 0) {
                console.log('nextTurn: Nenhum personagem disponível');
                return;
            }
            
            // Se não havia personagem ativo (início), iniciar no índice 0 e turno 1
            if (currentIndex === -1) {
                if (combatData.characters[0]) {
                    combatData.characters[0].isActive = true;
                    const nextNextIndex = combatData.characters.length > 1 ? 1 : 0;
                    if (combatData.characters[nextNextIndex]) {
                        combatData.characters[nextNextIndex].isNext = true;
                    }
                    combatData.currentTurn = 1;
                    combatData.rounds = 1; // Começa com 1 rodada
                }
                // rounds permanece como está (não conta como fim de rodada)
            } else {
                // definir novo personagem ativo
                if (combatData.characters[nextIndex]) {
                    combatData.characters[nextIndex].isActive = true;
                    const nextNextIndex = (nextIndex + 1) % combatData.characters.length;
                    if (combatData.characters[nextNextIndex]) {
                        combatData.characters[nextNextIndex].isNext = true;
                    }
                    
                    // Se voltamos ao índice 0, significa nova rodada
                    if (nextIndex === 0) {
                        combatData.rounds++;
                    }
                    
                    // Incrementar turno contador
                    combatData.currentTurn++;
                }
            }
            
            // Obter o personagem ativo atualizado
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) return;
            
            updateActiveCharacter();
            updateInitiativeList();
            updateTurnDisplay();
            updateSummary();
            updateSkillsList(); // Atualizar habilidades do novo personagem ativo
        }

        // ALTERNAR ENTRE BOTÕES DE AÇÃO E HABILIDADES
        function toggleSkillButtons() {
            const quickActions = document.getElementById('quickActions');
            const skillActions = document.getElementById('skillActions');
            
            if (quickActions.style.display === 'none') {
                quickActions.style.display = 'grid';
                skillActions.style.display = 'none';
            } else {
                quickActions.style.display = 'none';
                skillActions.style.display = 'grid';
            }
        }

        // USAR HABILIDADE ESPECÍFICA
        function useSkill(skillId) {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) return;
            
            // Carregar habilidades do personagem
            const characterSkills = getCharacterSkills(activeChar.id);
            const skill = characterSkills.find(s => s.id == skillId);
            
            if (!skill) {
                addLogEntry(`${activeChar.name} não possui essa habilidade!`, 'turn');
                playSoundEffect('error');
                return;
            }
            
            // Verificar se habilidade já está ativa (apenas para habilidades com duração)
            if (skill.active && skill.duration.value > 0) {
                addLogEntry(`${skill.name} já está ativa!`, 'turn');
                playSoundEffect('error');
                return;
            }
            
            // Verificar CO suficiente
            if (activeChar.co < skill.cost) {
                addLogEntry(`${activeChar.name} não tem CO suficiente para ${skill.name}!`, 'turn');
                playSoundEffect('error');
                return;
            }
            
            // Detectar tipo de efeito no texto
            const effectText = skill.effect.toLowerCase();
            let effectType = null;
            let effectValue = null;
            
            // Detectar dano
            if (effectText.includes('dano')) {
                effectType = 'damage';
                // Procurar por padrões como "1d4", "2d6", ou números fixos
                const diceMatch = effectText.match(/(\d+)d(\d+)/);
                const numberMatch = effectText.match(/(\d+)/);
                
                if (diceMatch) {
                    const numDice = parseInt(diceMatch[1]);
                    const dieSize = parseInt(diceMatch[2]);
                    effectValue = 0;
                    for (let i = 0; i < numDice; i++) {
                        effectValue += Math.floor(Math.random() * dieSize) + 1;
                    }
                } else if (numberMatch) {
                    effectValue = parseInt(numberMatch[1]);
                } else {
                    effectValue = 10; // valor padrão
                }
            }
            // Detectar cura
            else if (effectText.includes('cura')) {
                effectType = 'heal';
                // Procurar por padrões como "1d4", "2d6", ou números fixos
                const diceMatch = effectText.match(/(\d+)d(\d+)/);
                const numberMatch = effectText.match(/(\d+)/);
                
                if (diceMatch) {
                    const numDice = parseInt(diceMatch[1]);
                    const dieSize = parseInt(diceMatch[2]);
                    effectValue = 0;
                    for (let i = 0; i < numDice; i++) {
                        effectValue += Math.floor(Math.random() * dieSize) + 1;
                    }
                } else if (numberMatch) {
                    effectValue = parseInt(numberMatch[1]);
                } else {
                    effectValue = 10; // valor padrão
                }
            }
            
            // Verificar se precisa selecionar alvo
            if (skill.target === 'qualquer_criatura' || (effectType && skill.target !== 'nenhum')) {
                // Abrir modal de seleção de alvo
                openSkillTargetSelection(skillId, effectType, effectValue);
                return;
            }

            // Aplicar efeito imediato (para si mesmo ou alvo nenhum)
            applySkillEffect(activeChar, skill, effectType, effectValue, activeChar);
        }

        // ABRIR MODAL DE SELEÇÃO DE ALVO PARA HABILIDADE
        function openSkillTargetSelection(skillId, effectType, effectValue) {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) return;
            
            const container = document.getElementById('itemModalContainer');
            const characterSkills = getCharacterSkills(activeChar.id);
            const skill = characterSkills.find(s => s.id == skillId);
            
            if (!skill) return;
            
            // Construir HTML do modal com lista de alvos
            let modalHtml = `
                <div class="item-modal-backdrop" onclick="closeSkillTargetModal(event)">
                    <div class="item-modal" onclick="event.stopPropagation()">
                        <h3><i class="fas fa-bullseye"></i> Selecionar Alvo para ${skill.name}</h3>
                        <div class="target-list">
            `;
            
            // Adicionar opção para si mesmo se permitido
            if (skill.target === 'si_mesmo' || skill.target === 'qualquer_criatura') {
                modalHtml += `
                    <div class="target-item" onclick="selectSkillTarget('${skillId}', '${activeChar.id}', '${effectType}', ${effectValue})" style="cursor:pointer;padding:12px;border:1px solid rgba(255,255,255,0.1);border-radius:8px;margin-bottom:8px;background:rgba(255,255,255,0.05);transition:all 0.3s ease;">
                        <div class="target-info">
                            <div class="target-name" style="font-weight:600;color:var(--accent-blue);">${activeChar.name} (Si Mesmo)</div>
                            <div class="target-stats" style="font-size:0.9rem;color:rgba(255,255,255,0.7);">HP: ${activeChar.hp}/${activeChar.maxHp} | CO: ${activeChar.co}/${activeChar.maxCo}</div>
                        </div>
                    </div>
                `;
            }
            
            // Adicionar outros personagens como alvos
            if (skill.target === 'qualquer_criatura') {
                combatData.characters.forEach(char => {
                    if (char.id !== activeChar.id) {
                        modalHtml += `
                            <div class="target-item" onclick="selectSkillTarget('${skillId}', '${char.id}', '${effectType}', ${effectValue})" style="cursor:pointer;padding:12px;border:1px solid rgba(255,255,255,0.1);border-radius:8px;margin-bottom:8px;background:rgba(255,255,255,0.05);transition:all 0.3s ease;">
                                <div class="target-info">
                                    <div class="target-name" style="font-weight:600;color:var(--text);">${char.name}</div>
                                    <div class="target-stats" style="font-size:0.9rem;color:rgba(255,255,255,0.7);">HP: ${char.hp}/${char.maxHp} | CO: ${char.co}/${char.maxCo}</div>
                                </div>
                            </div>
                        `;
                    }
                });
            }
            
            modalHtml += `
                        </div>
                        <div class="modal-buttons">
                            <button type="button" class="modal-btn cancel" onclick="closeSkillTargetModal()">CANCELAR</button>
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = modalHtml;
            container.style.display = 'block';
        }

        // FECHAR MODAL DE SELEÇÃO DE ALVO DE HABILIDADE
        function closeSkillTargetModal(e) {
            if (e && e.target !== e.currentTarget) return;
            const container = document.getElementById('itemModalContainer');
            container.style.display = 'none';
            container.innerHTML = '';
        }

        // SELECIONAR ALVO E APLICAR HABILIDADE
        function selectSkillTarget(skillId, targetId, effectType, effectValue) {
            const activeChar = combatData.characters.find(c => c.isActive);
            const targetChar = combatData.characters.find(c => c.id == targetId);
            const characterSkills = getCharacterSkills(activeChar.id);
            const skill = characterSkills.find(s => s.id == skillId);
            
            if (!targetChar || !skill) return;
            
            // Aplicar efeito da habilidade
            applySkillEffect(activeChar, skill, effectType, effectValue, targetChar);
            
            // Fechar modal
            closeSkillTargetModal();
        }

        // APLICAR EFEITO DA HABILIDADE
        function applySkillEffect(userChar, skill, effectType, effectValue, targetChar) {
            // Consumir CO
            userChar.co -= skill.cost;
            combatData.coSpentThisTurn += skill.cost;
            
            // Verificar se é habilidade instantânea ou de duração
            const isInstantSkill = skill.duration.value === 0 || 
                                 (skill.duration.type === 'number' && skill.duration.value === 0);
            
            if (isInstantSkill) {
                // Habilidade instantânea - não fica ativa
                addLogEntry(`${userChar.name} usou ${skill.name}!`, 'turn');
            } else {
                // Habilidade de duração - ativar e definir turnos
                if (skill.duration.type === 'dice') {
                    // Rolar os dados para determinar duração
                    const diceMatch = skill.duration.value.match(/(\d+)d(\d+)/);
                    if (diceMatch) {
                        const numDice = parseInt(diceMatch[1]);
                        const dieSize = parseInt(diceMatch[2]);
                        let total = 0;
                        
                        for (let i = 0; i < numDice; i++) {
                            total += Math.floor(Math.random() * dieSize) + 1;
                        }
                        
                        skill.remainingTurns = total;
                        skill.active = true;
                        
                        addLogEntry(`${userChar.name} ativou ${skill.name} por ${total} turnos!`, 'turn');
                    }
                } else {
                    // Duração fixa
                    skill.remainingTurns = skill.duration.value;
                    skill.active = true;
                    
                    addLogEntry(`${userChar.name} ativou ${skill.name} por ${skill.duration.value} turnos!`, 'turn');
                }
            }
            
            // Aplicar efeito de dano ou cura
            if (effectType === 'damage' && effectValue) {
                // Chance de crítico maior para habilidades (25%)
                if (Math.random() < 0.25) {
                    showCriticalPopup();
                    const criticalDamage = effectValue * 2;
                    targetChar.hp = Math.max(0, targetChar.hp - criticalDamage);
                    combatData.damageThisTurn += criticalDamage;
                    
                    if (userChar.id === targetChar.id) {
                        addLogEntry(`${userChar.name} usou ${skill.name} em si mesmo (CRÍTICO! ${criticalDamage} de dano)`, 'damage');
                    } else {
                        addLogEntry(`${userChar.name} usou ${skill.name} em ${targetChar.name} (CRÍTICO! ${criticalDamage} de dano)`, 'damage');
                    }
                } else {
                    targetChar.hp = Math.max(0, targetChar.hp - effectValue);
                    combatData.damageThisTurn += effectValue;
                    
                    if (userChar.id === targetChar.id) {
                        addLogEntry(`${userChar.name} usou ${skill.name} em si mesmo (${effectValue} de dano)`, 'damage');
                    } else {
                        addLogEntry(`${userChar.name} usou ${skill.name} em ${targetChar.name} (${effectValue} de dano)`, 'damage');
                    }
                }
            } else if (effectType === 'heal' && effectValue) {
                const actualHeal = Math.min(effectValue, targetChar.maxHp - targetChar.hp);
                targetChar.hp += actualHeal;
                
                if (userChar.id === targetChar.id) {
                    addLogEntry(`${userChar.name} usou ${skill.name} em si mesmo (curou ${actualHeal} PV)`, 'heal');
                } else {
                    addLogEntry(`${userChar.name} usou ${skill.name} em ${targetChar.name} (curou ${actualHeal} PV)`, 'heal');
                }
            } else {
                // Efeito genérico sem dano/cura
                if (userChar.id === targetChar.id) {
                    addLogEntry(`${userChar.name} usou ${skill.name} em si mesmo - ${skill.effect}`, 'turn');
                } else {
                    addLogEntry(`${userChar.name} usou ${skill.name} em ${targetChar.name} - ${skill.effect}`, 'turn');
                }
            }
            
            // Sincronizar habilidades com a ficha
            const characterSkills = getCharacterSkills(userChar.id);
            syncSkillsToSheet(characterSkills);
            
            // Atualizar interface
            updateActiveCharacter();
            updateInitiativeList();
            updateSummary();
            updateSkillsList();
            playSoundEffect('skill');
            
            // Voltar para os botões originais após usar a habilidade
            toggleSkillButtons();
        }

        // Obter habilidades do personagem
        function getCharacterSkills(characterId) {
            try {
                const characterKey = `characterSkills_${characterId}`;
                const savedSkills = localStorage.getItem(characterKey);
                
                if (savedSkills) {
                    return JSON.parse(savedSkills);
                } else {
                    // Tentar carregar do characterInfo geral
                    const characterInfo = localStorage.getItem('characterSkills');
                    if (characterInfo) {
                        const info = JSON.parse(characterInfo);
                        if (info.characterId === characterId && Array.isArray(info.skills)) {
                            return info.skills;
                        }
                    }
                }
            } catch(e) {
                console.error('Erro ao carregar habilidades do personagem:', e);
            }
            
            return [];
        }

        // Sincronizar habilidades com a ficha
        function syncSkillsToSheet(skills) {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) {
                console.log('❌ SyncSkillsToSheet - Nenhum personagem ativo');
                return;
            }
            
            console.log('🔄 SyncSkillsToSheet - Personagem:', activeChar.name, 'Habilidades:', skills.length);
            
            // Salvar habilidades específicas do personagem usando seu ID
            const characterKey = `characterSkills_${activeChar.id}`;
            localStorage.setItem(characterKey, JSON.stringify(skills));
            
            // Disparar evento para notificar outras páginas
            localStorage.setItem('skillsUpdated', Date.now().toString());
            console.log('📢 Evento skillsUpdated disparado');
        }

        // Atualizar lista de habilidades na interface
        function updateSkillsList() {
            const skillsList = document.getElementById('skillsList');
            if (!skillsList) return;
            
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) {
                skillsList.innerHTML = '<div class="empty-items">Nenhum personagem ativo</div>';
                return;
            }
            
            const characterSkills = getCharacterSkills(activeChar.id);
            
            if (characterSkills.length === 0) {
                skillsList.innerHTML = '<div class="empty-items">Nenhuma habilidade disponível</div>';
                return;
            }
            
            skillsList.innerHTML = '';
            
            characterSkills.forEach(skill => {
                const skillCard = document.createElement('div');
                skillCard.className = 'item-card';
                
                let durationText = '';
                if (skill.duration.type === 'number') {
                    durationText = `${skill.duration.value} turnos`;
                } else {
                    durationText = `${skill.duration.value} (rolagem)`;
                }
                
                let statusText = '';
                let canUse = true;
                
                if (skill.active) {
                    statusText = ` [ATIVA: ${skill.remainingTurns} turnos]`;
                    skillCard.style.borderColor = 'var(--accent-yellow)';
                    skillCard.style.background = 'rgba(255, 229, 0, 0.1)';
                    canUse = false;
                }
                
                const targetText = {
                    'qualquer_criatura': 'Qualquer Criatura',
                    'si_mesmo': 'A Si Mesmo',
                    'nenhum': 'Nenhum'
                }[skill.target] || skill.target;
                
                // Verificar se personagem tem CO suficiente
                const hasEnoughCO = activeChar.co >= skill.cost;
                
                skillCard.innerHTML = `
                    <div class="item-info">
                        <div class="item-name">${skill.name} (CO: ${skill.cost})${statusText}</div>
                        <div class="item-effect">${skill.effect}</div>
                        <div class="item-details">Duração: ${durationText} | Alvo: ${targetText}</div>
                    </div>
                    <div class="item-controls">
                        ${canUse && hasEnoughCO ? `<button class="item-btn use" onclick="useSkill('${skill.id}')">USAR</button>` : ''}
                        ${!hasEnoughCO && canUse ? `<button class="item-btn" disabled style="opacity:0.5;">SEM CO</button>` : ''}
                        ${skill.active ? `<button class="item-btn" style="background:rgba(255,193,7,0.2);border-color:#FFC107;">ATIVA</button>` : ''}
                    </div>
                `;
                skillsList.appendChild(skillCard);
            });
        }

        // Decrementar contadores de habilidades no próximo turno
        function decrementSkillTurns() {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) return;
            
            const characterSkills = getCharacterSkills(activeChar.id);
            let updated = false;
            
            characterSkills.forEach(skill => {
                if (skill.active && skill.remainingTurns > 0) {
                    skill.remainingTurns--;
                    if (skill.remainingTurns === 0) {
                        skill.active = false;
                        addLogEntry(`${skill.name} expirou!`, 'turn');
                    }
                    updated = true;
                }
            });
            
            if (updated) {
                syncSkillsToSheet(characterSkills);
                updateSkillsList();
            }
        }

        // ABRIR MODAL PARA ADICIONAR ITEM
        function openAddItemModal() {
            const container = document.getElementById('itemModalContainer');
            
            const modalHtml = `
                <div class="item-modal-backdrop" onclick="closeItemModal(event)">
                    <div class="item-modal" onclick="event.stopPropagation()">
                        <h3><i class="fas fa-plus"></i> ADICIONAR NOVO ITEM</h3>
                        
                        <form id="addItemForm" onsubmit="addItem(event)">
                            <div class="form-group">
                                <label for="itemName">Nome do Item</label>
                                <input type="text" id="itemName" name="itemName" required placeholder="Ex: Poção de Cura">
                            </div>
                            
                            <div class="form-group">
                                <label for="itemEffect">Efeito do Item</label>
                                <textarea id="itemEffect" name="itemEffect" required placeholder="Ex: Restaura 20 pontos de vida"></textarea>
                            </div>
                            
                            <div class="form-row">
                                <div class="form-group">
                                    <label for="itemConsumable">É Consumível?</label>
                                    <select id="itemConsumable" name="itemConsumable" required onchange="toggleConsumableFields()">
                                        <option value="true">Sim</option>
                                        <option value="false">Não</option>
                                    </select>
                                </div>
                                
                                <div class="form-group" id="usesGroup">
                                    <label for="itemUses">Usos Restantes</label>
                                    <input type="number" id="itemUses" name="itemUses" min="0" value="1">
                                </div>
                            </div>
 　 　 　 　 　 　 　 　 　
                            <div class="form-row">
                                <div class="form-group">
                                    <label for="itemTargetable">Usável em Criaturas?</label>
                                    <select id="itemTargetable" name="itemTargetable" required>
                                        <option value="false">Apenas em si mesmo</option>
                                        <option value="true">Em qualquer criatura</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label for="itemSpace">Espaço no Inventário</label>
                                    <input type="number" id="itemSpace" name="itemSpace" min="1" value="1" required placeholder="Quantos espaços ocupa">
                                </div>
                            </div>
                            
                            <div class="modal-buttons">
                                <button type="button" class="modal-btn cancel" onclick="closeItemModal()">CANCELAR</button>
                                <button type="submit" class="modal-btn">ADICIONAR ITEM</button>
                            </div>
                        </form>
                    </div>
                </div>
            `;
            
            container.innerHTML = modalHtml;
            container.style.display = 'block';
        }

        // FECHAR MODAL DE ITENS
        function closeItemModal(e) {
            if (e && e.target !== e.currentTarget) return;
            const container = document.getElementById('itemModalContainer');
            container.style.display = 'none';
            container.innerHTML = '';
        }

        // ALTERNAR CAMPOS DE CONSUMÍVEL
        function toggleConsumableFields() {
            const isConsumable = document.getElementById('itemConsumable').value === 'true';
            const usesGroup = document.getElementById('usesGroup');
            
            if (isConsumable) {
                usesGroup.style.display = 'block';
                document.getElementById('itemUses').required = true;
            } else {
                usesGroup.style.display = 'none';
                document.getElementById('itemUses').required = false;
                document.getElementById('itemUses').value = '0';
            }
        }

        // ADICIONAR ITEM AO INVENTÁRIO
        function addItem(event) {
            event.preventDefault();
            
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) {
                addLogEntry('Nenhum personagem ativo para adicionar item!', 'turn');
                return;
            }
            
            const formData = new FormData(event.target);
            const isConsumable = formData.get('itemConsumable') === 'true';
            
            const newItem = {
                id: Date.now(), // ID único baseado no timestamp
                name: formData.get('itemName'),
                effect: formData.get('itemEffect'),
                consumable: isConsumable,
                uses: isConsumable ? parseInt(formData.get('itemUses')) : 0,
                targetable: formData.get('itemTargetable') === 'true',
                space: parseInt(formData.get('itemSpace'))
            };
            
            // Inicializar inventário se não existir
            if (!activeChar.inventory) {
                activeChar.inventory = [];
            }
            
            // Adicionar item ao inventário
            activeChar.inventory.push(newItem);
            
            // Sincronizar com a ficha
            syncItemsToSheet(activeChar.inventory);
            
            addLogEntry(`${activeChar.name} adicionou "${newItem.name}" ao inventário`, 'turn');
            playSoundEffect('itemAdd');
            
            // Fechar modal e atualizar lista
            closeItemModal();
            updateItemsList();
        }

        // Sincronizar itens com a ficha
        function syncItemsToSheet(items) {
            // Obter personagem ativo
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) {
                console.log('❌ SyncItemsToSheet - Nenhum personagem ativo');
                return;
            }
            
            console.log('🔄 SyncItemsToSheet - Personagem:', activeChar.name, 'Itens:', items.length);
            
            // Salvar itens específicos do personagem usando seu ID
            const characterKey = `characterItems_${activeChar.id}`;
            localStorage.setItem(characterKey, JSON.stringify(items));
            console.log('💾 Salvou itens em:', characterKey);
            
            // Salvar também informações do personagem para a ficha
            const characterInfo = {
                characterId: activeChar.id,
                characterName: activeChar.name,
                items: items
            };
            localStorage.setItem('characterItems', JSON.stringify(characterInfo));
            
            // Disparar evento para notificar outras páginas
            localStorage.setItem('itemsUpdated', Date.now().toString());
            console.log('📢 Evento itemsUpdated disparado da página principal');
        }

        // Carregar itens da ficha
        function loadItemsFromSheet() {
            console.log('📥 LoadItemsFromSheet - Iniciando carregamento');
            try {
                const activeChar = combatData.characters.find(c => c.isActive);
                if (!activeChar) {
                    console.log('❌ Nenhum personagem ativo encontrado');
                    // Se não houver personagem ativo, tentar carregar itens pendentes
                    const pendingItems = localStorage.getItem('pendingItems');
                    if (pendingItems) {
                        const items = JSON.parse(pendingItems);
                        if (Array.isArray(items) && items.length > 0) {
                            localStorage.setItem('pendingItems', JSON.stringify(items));
                        }
                    }
                    return;
                }
                
                console.log('✅ Personagem ativo:', activeChar.name, 'ID:', activeChar.id);
                
                // Tentar carregar itens específicos do personagem
                const characterKey = `characterItems_${activeChar.id}`;
                const savedItems = localStorage.getItem(characterKey);
                
                console.log('🔍 Procurando itens em:', characterKey);
                
                if (savedItems) {
                    const items = JSON.parse(savedItems);
                    if (Array.isArray(items)) {
                        if (!activeChar.inventory) {
                            activeChar.inventory = [];
                        }
                        activeChar.inventory = items;
                        updateItemsList();
                        console.log('✅ Itens carregados do personagem:', items.length);
                    }
                } else {
                    // Tentar carregar do characterInfo geral
                    const characterInfo = localStorage.getItem('characterItems');
                    if (characterInfo) {
                        const info = JSON.parse(characterInfo);
                        if (info.characterId === activeChar.id && Array.isArray(info.items)) {
                            if (!activeChar.inventory) {
                                activeChar.inventory = [];
                            }
                            activeChar.inventory = info.items;
                            updateItemsList();
                            console.log('✅ Itens carregados do characterInfo:', info.items.length);
                        }
                    }
                }
            } catch(e) {
                console.error('Erro ao carregar itens da ficha:', e);
            }
        }

        // ATUALIZAR LISTA DE ITENS
        function updateItemsList() {
            const activeChar = combatData.characters.find(c => c.isActive);
            const itemsList = document.getElementById('itemsList');
            
            if (!activeChar || !activeChar.inventory || activeChar.inventory.length === 0) {
                itemsList.innerHTML = '<div class="empty-items">Nenhum item no inventário</div>';
                return;
            }
            
            itemsList.innerHTML = '';
            
            activeChar.inventory.forEach(item => {
                const itemCard = document.createElement('div');
                itemCard.className = 'item-card';
                
                const usesText = item.consumable ? ` (${item.uses} usos)` : '';
                const spaceText = item.space > 1 ? ` [${item.space} espaços]` : '';
                
                itemCard.innerHTML = `
                    <div class="item-info">
                        <div class="item-name">${item.name}${usesText}${spaceText}</div>
                        <div class="item-effect">${item.effect}</div>
                        <div class="item-details">${item.consumable ? 'Consumível' : 'Permanente'}</div>
                    </div>
                    <div class="item-controls">
                        ${item.consumable && item.uses > 0 ? 
                            `<button class="item-btn use" onclick="useItem('${item.id}')">USAR</button>` : 
                            item.consumable ? 
                            `<button class="item-btn" disabled>ESGOTADO</button>` : 
                            `<button class="item-btn use" onclick="useItem('${item.id}')">USAR</button>`
                        }
                        <button class="item-btn" onclick="removeItem('${item.id}')">REMOVER</button>
                    </div>
                `;
                itemsList.appendChild(itemCard);
            });
        }

        // USAR ITEM
        function useItem(itemId) {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) return;
            
            const item = activeChar.inventory.find(i => i.id == itemId);
            if (!item) return;
            
            // Verificar se item pode ser usado em outras criaturas
            if (item.targetable) {
                // Abrir modal de seleção de alvo
                openTargetSelectionModal(itemId);
            } else {
                // Usar diretamente no personagem ativo
                applyItemEffect(activeChar, item, activeChar);
            }
        }

        // ABRIR MODAL DE SELEÇÃO DE ALVO
        function openTargetSelectionModal(itemId) {
            const activeChar = combatData.characters.find(c => c.isActive);
            const item = activeChar.inventory.find(i => i.id == itemId);
            if (!item) return;
            
            const container = document.getElementById('itemModalContainer');
            
            // Gerar HTML com lista de personagens como alvos
            let targetsHtml = '';
            combatData.characters.forEach(char => {
                const hpPercent = Math.round((char.hp / char.maxHp) * 100);
                const isActive = char.isActive ? 'active' : '';
                const statusIcon = char.isActive ? '⭐' : '';
                
                targetsHtml += `
                    <div class="target-item ${isActive}" onclick="selectTarget('${itemId}', '${char.id}')">
                        <div class="target-info">
                            <div class="target-name">${char.name} ${statusIcon}</div>
                            <div class="target-stats">
                                <span>HP: ${char.hp}/${char.maxHp}</span>
                                <span>CO: ${char.co}/${char.maxCo}</span>
                            </div>
                            <div class="progress-bar" style="height: 4px; background: rgba(255,255,255,0.1); margin-top: 5px; border-radius: 2px;">
                                <div style="height: 100%; width: ${hpPercent}%; background: ${hpPercent > 50 ? '#34C759' : hpPercent > 25 ? '#FF9500' : '#FF3B30'}; border-radius: 2px;"></div>
                            </div>
                        </div>
                        <div class="target-avatar">${char.avatar}</div>
                    </div>
                `;
            });
            
            const modalHtml = `
                <div class="item-modal-backdrop" onclick="closeTargetSelectionModal(event)">
                    <div class="item-modal" onclick="event.stopPropagation()">
                        <h3><i class="fas fa-crosshairs"></i> SELECIONAR ALVO PARA ${item.name.toUpperCase()}</h3>
                        <p style="color: rgba(255,255,255,0.7); margin-bottom: 20px;">Escolha quem receberá o efeito: ${item.effect}</p>
                        
                        <div class="targets-list">
                            ${targetsHtml}
                        </div>
                        
                        <div class="modal-buttons">
                            <button type="button" class="modal-btn cancel" onclick="closeTargetSelectionModal()">CANCELAR</button>
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = modalHtml;
            container.style.display = 'block';
        }

        // FECHAR MODAL DE SELEÇÃO DE ALVO
        function closeTargetSelectionModal(e) {
            if (e && e.target !== e.currentTarget) return;
            const container = document.getElementById('itemModalContainer');
            container.style.display = 'none';
            container.innerHTML = '';
        }

        // SELECIONAR ALVO E APLICAR ITEM
        function selectTarget(itemId, targetId) {
            const activeChar = combatData.characters.find(c => c.isActive);
            const targetChar = combatData.characters.find(c => c.id == targetId);
            const item = activeChar.inventory.find(i => i.id == itemId);
            
            if (!targetChar || !item) return;
            
            // Aplicar efeito no alvo
            applyItemEffect(activeChar, item, targetChar);
            
            // Fechar modal
            closeTargetSelectionModal();
        }

        // APLICAR EFEITO DO ITEM
        function applyItemEffect(userChar, item, targetChar) {
            // Verificar se o item pode ser usado
            if (item.consumable && item.uses <= 0) {
                addLogEntry(`${item.name} não tem usos restantes!`, 'turn');
                return;
            }
            
            let effectMessage = '';
            let logType = 'turn';
            
            // Verificar se é uma poção de cura
            if (item.name.toLowerCase().includes('cura') || item.effect.toLowerCase().includes('vida') || item.effect.toLowerCase().includes('cura')) {
                const healAmount = 20; // Valor fixo por enquanto
                const actualHeal = Math.min(healAmount, targetChar.maxHp - targetChar.hp);
                targetChar.hp += actualHeal;
                effectMessage = ` (curou ${actualHeal} PV)`;
                logType = 'heal';
            }
            // Verificar se é uma poção de CO/energia
            else if (item.name.toLowerCase().includes('co') || item.name.toLowerCase().includes('energia') || item.effect.toLowerCase().includes('co')) {
                const restoreAmount = 5; // Valor fixo por enquanto
                const actualRestore = Math.min(restoreAmount, targetChar.maxCo - targetChar.co);
                targetChar.co += actualRestore;
                effectMessage = ` (restaurou ${actualRestore} CO)`;
                logType = 'turn';
            }
            else {
                // Efeito genérico
                effectMessage = ` - ${item.effect}`;
                logType = 'turn';
            }
            
            // Mensagem de log diferenciada para uso em si mesmo vs outros
            if (userChar.id === targetChar.id) {
                addLogEntry(`${userChar.name} usou ${item.name} em si mesmo${effectMessage}`, logType);
            } else {
                addLogEntry(`${userChar.name} usou ${item.name} em ${targetChar.name}${effectMessage}`, logType);
            }
            
            // Reduzir usos se for consumível
            if (item.consumable) {
                item.uses--;
                
                // Remover item se usos chegaram a 0
                if (item.uses <= 0) {
                    const itemIndex = userChar.inventory.findIndex(i => i.id == item.id);
                    userChar.inventory.splice(itemIndex, 1);
                    addLogEntry(`${item.name} foi completamente usado e removido do inventário`, 'turn');
                    
                    // Sincronizar remoção com a ficha
                    syncItemsToSheet(userChar.inventory);
                } else {
                    // Sincronizar redução de usos com a ficha
                    syncItemsToSheet(userChar.inventory);
                }
            }
            
            // Atualizar interface
            updateActiveCharacter();
            updateInitiativeList();
            updateItemsList();
            playSoundEffect('itemUse');
        }

        // REMOVER ITEM DO INVENTÁRIO
        function removeItem(itemId) {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) return;
            
            const itemIndex = activeChar.inventory.findIndex(i => i.id == itemId);
            if (itemIndex === -1) return;
            
            const removedItem = activeChar.inventory[itemIndex];
            activeChar.inventory.splice(itemIndex, 1);
            
            // Sincronizar com a ficha
            syncItemsToSheet(activeChar.inventory);
            
            addLogEntry(`${activeChar.name} removeu "${removedItem.name}" do inventário`, 'turn');
            updateItemsList();
            playSoundEffect('itemRemove');
        }

        // MOSTRAR POPUP DE CRÍTICO
        function showCriticalPopup() {
            const popup = document.getElementById('criticalPopup');
            popup.style.display = 'block';
            
            // Reproduzir som de crítico (simulado)
            playSoundEffect('critical');
            
            // Remover após 1.5 segundos
            setTimeout(() => {
                popup.style.display = 'none';
            }, 1500);
        }

        // ABRIR MODAL DE ADIÇÃO E ESCOLHA DE FICHA
        function openAddModal() {
            const container = document.getElementById('sheetModalContainer');
            const saved = JSON.parse(localStorage.getItem('sheetRepo')) || [];
            const allSheets = [...hexSheets, ...saved];

            // construir HTML do modal usando propriedades seguras (suporta sheet.meta/recursos)
            let modalHtml = `
                <div class="sheet-modal-backdrop" onclick="closeSheetModal(event)">
                    <div class="sheet-modal" onclick="event.stopPropagation()">
                        <h3 style="margin-bottom:10px;">Repositório H.E.X.A - Escolha uma ficha</h3>
            `;

            allSheets.forEach(s => {
                const name = s.name || (s.meta && (s.meta.name || s.meta.nome)) || '';
                const avatar = s.avatar || (s.meta && s.meta.avatar) || '';
                const arche = s.archetype || (s.meta && (s.meta.archetype || s.meta.arquetipo)) || '';
                const pv = (s.hp != null) ? s.hp : (s.recursos && s.recursos.vitalidade) || (s.meta && (s.meta.vitalidade || s.meta.vit_atual)) || '-';
                const maxPv = (s.maxHp != null) ? s.maxHp : (s.recursos && s.recursos.vitalidade) || (s.meta && (s.meta.vitalidade || s.meta.vit_max)) || '-';
                // unified carga-operacional: prefer recursos.carga_operacional, then carga_atual / carga_maxima, then meta fallbacks
                const coVal = (s.co != null) ? s.co : (s.recursos && (s.recursos.carga_operacional != null ? s.recursos.carga_operacional : (s.recursos.carga_atual != null ? s.recursos.carga_atual : s.recursos.carga_maxima))) || (s.meta && (s.meta.co || s.meta.co_atual)) || '-';
                const maxCoVal = (s.maxCo != null) ? s.maxCo : (s.recursos && (s.recursos.carga_operacional != null ? s.recursos.carga_operacional : (s.recursos.carga_maxima != null ? s.recursos.carga_maxima : s.recursos.carga_atual))) || (s.meta && (s.meta.maxCo || s.meta.carga_maxima)) || '-';

                modalHtml += `
                    <div class="sheet-item" id="sheet-${s.sheetId}">
                        <div>
                            <div style="font-size:1.1rem;"><strong>${name}</strong> ${avatar}</div>
                            <div style="font-size:0.85rem; color:rgba(255,255,255,0.7)">${arche} — PV ${pv} / ${maxPv} • CO ${coVal} / ${maxCoVal}</div>
                        </div>
                        <div style="display:flex;flex-direction:column;gap:6px;">
                            <button onclick="addCharFromSheet('${s.sheetId}')">Adicionar</button>
                            <button onclick="editSheet('${s.sheetId}')" style="background:#444;color:#fff;padding:6px;border-radius:6px;border:none;cursor:pointer;">Editar</button>
                            <button onclick="deleteSheetFromRepo('${s.sheetId}')" style="background:#b71c1c;color:#fff;padding:6px;border-radius:6px;border:none;cursor:pointer;">Excluir</button>
                        </div>
                    </div>
                `;
            });

            modalHtml += `
                        <div style="text-align:right; margin-top:8px;">
                            <button onclick="closeSheetModal()" style="background:#444; color:#fff; padding:6px 10px; border-radius:8px; border:none; cursor:pointer;">Fechar</button>
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = modalHtml;
            container.style.display = 'block';
        }

        function closeSheetModal(e) {
            if (e && e.target !== e.currentTarget) return;
            const container = document.getElementById('sheetModalContainer');
            container.style.display = 'none';
            container.innerHTML = '';
        }

        // ADICIONA UMA FICHA ESCOLHIDA AO COMBATE
        function addCharFromSheet(sheetId) {
            const saved = JSON.parse(localStorage.getItem('sheetRepo')) || [];
            const sheet = hexSheets.find(s => s.sheetId === sheetId) || saved.find(s => s.sheetId === sheetId);
            if (!sheet) return;

            // suportar formatos antigos (flat) e novos (com meta/atributos/recursos)
            const name = sheet.name || (sheet.meta && sheet.meta.name) || 'Sem nome';
            const archetype = sheet.archetype || (sheet.meta && sheet.meta.archetype) || (sheet.meta && sheet.meta.archetype) || '';
            const avatar = sheet.avatar || (sheet.meta && sheet.meta.avatar) || sheet.avatar || '🙂';
            const hp = (sheet.hp != null) ? sheet.hp : (sheet.recursos && sheet.recursos.vitalidade) || (sheet.meta && sheet.meta.vitalidade) || 0;
            const maxHp = (sheet.maxHp != null) ? sheet.maxHp : (sheet.recursos && sheet.recursos.vitalidade) || hp || 0;
            // set both current and max CO from unified carga_operacional when available
            const coFromRecursos = sheet.recursos && (sheet.recursos.carga_operacional != null ? sheet.recursos.carga_operacional : (sheet.recursos.carga_atual != null ? sheet.recursos.carga_atual : sheet.recursos.carga_maxima));
            const co = (sheet.co != null) ? sheet.co : (coFromRecursos != null ? coFromRecursos : 0);
            const maxCo = (sheet.maxCo != null) ? sheet.maxCo : (coFromRecursos != null ? coFromRecursos : co || 0);
            const initiative = sheet.initiative || Math.floor(Math.random()*20)+1;

            const newChar = {
                id: sheetId, // Usar o sheetId original em vez de ID numérico
                name,
                hp: Number(hp),
                maxHp: Number(maxHp),
                co: Number(co),
                maxCo: Number(maxCo),
                initiative,
                avatar,
                isActive: false,
                isNext: false,
                archetype,
                protocolos: sheet.protocolos || {}
            };
            combatData.characters.push(newChar);
            updateInitiativeList();
            addLogEntry(`<strong>${newChar.name}</strong> entrou no combate`);
            playSoundEffect('characterAdd');
            closeSheetModal();
            
            // Se este for o primeiro personagem, torná-lo ativo e carregar habilidades
            if (combatData.characters.length === 1) {
                newChar.isActive = true;
                updateActiveCharacter();
                updateSkillsList();
            }
        }

        // Deleta uma ficha do repositório (usuário)
        function deleteSheetFromRepo(sheetId) {
            const sheetRepo = JSON.parse(localStorage.getItem('sheetRepo')) || [];
            const idx = sheetRepo.findIndex(s => s.sheetId === sheetId);
            if (idx === -1) return;
            const removed = sheetRepo.splice(idx, 1)[0];
            localStorage.setItem('sheetRepo', JSON.stringify(sheetRepo));
            localStorage.setItem('sheetRepoUpdated', JSON.stringify({ sheetId: sheetId, action: 'deleted', time: Date.now() }));
            const removedName = (removed && (removed.name || (removed.meta && (removed.meta.name || removed.meta.nome)))) || 'Sem nome';
            addLogEntry(`<strong>${removedName}</strong> foi removido do repositório`);
            // atualizar modal
            openAddModal();
        }

        // Abrir a ficha para edição em nova aba
        function editSheet(sheetId) {
            // abrir a página de criação com parâmetro ?edit=sheetId
            window.open('pages/create_character.html?edit=' + encodeURIComponent(sheetId), '_blank');
        }

        // RESETAR TIMER E CONTADORES
        function resetCombat() {
            combatData.timer = 0;
            combatData.currentTurn = 0;
            combatData.rounds = 0;
            combatData.damageThisTurn = 0;
            combatData.coSpentThisTurn = 0;
            combatData.characters.forEach(c => { c.isActive = false; c.isNext = false; });
            updateTurnDisplay();
            updateInitiativeList();
            updateActiveCharacter();
            updateSummary();
            addLogEntry('Combate resetado pelo usuário', 'turn');
            playSoundEffect('reset');
        }

        // SIMULAR EFEITOS SONOROS
        function playSoundEffect(type) {
            // Em uma implementação real, você tocaria arquivos de áudio
            console.log(`Som reproduzido: ${type}`);
        }

        // INICIAR QUANDO A PÁGINA CARREGAR
        window.onload = function() {
            initCombat();
            // Tentar carregar itens da ficha ao iniciar
            loadItemsFromSheet();
        };

        // CARREGAR PERSONAGENS DO LOCAL STORAGE
        function loadCharacters() {
            const characters = JSON.parse(localStorage.getItem('characters')) || [];
            const characterList = document.getElementById('character-list');
            characterList.innerHTML = '';

            characters.forEach((character, index) => {
                const characterItem = document.createElement('div');
                characterItem.innerHTML = `
                    <p><strong>${character.name}</strong> - Nível: ${character.level}</p>
                    <button onclick="removeCharacter(${index})">Remover</button>
                `;
                characterList.appendChild(characterItem);
            });
        }

        // REMOVER PERSONAGEM DO LOCAL STORAGE
        function removeCharacter(index) {
            const characters = JSON.parse(localStorage.getItem('characters')) || [];
            characters.splice(index, 1);
            localStorage.setItem('characters', JSON.stringify(characters));
            loadCharacters();
        }

        document.addEventListener('DOMContentLoaded', loadCharacters);

        // Ouvir atualizações vindas de outras abas (ex.: página de criação salvou no sheetRepo)
        window.addEventListener('storage', function(e) {
            if (!e.key) return;
            if (e.key === 'sheetRepoUpdated') {
                try {
                    const payload = JSON.parse(e.newValue || '{}');
                    console.log('sheetRepoUpdated recebido:', payload);
                } catch (err) {
                    console.log('sheetRepoUpdated recebido (não JSON)');
                }
                // Abre o modal de adição automaticamente
                openAddModal();

                // destacar (visual) a ficha recém-criada no modal, se possível
                setTimeout(() => {
                    try {
                        const raw = localStorage.getItem('sheetRepoUpdated');
                        const info = raw ? JSON.parse(raw) : null;
                        if (info && info.sheetId) {
                            const modal = document.querySelector('.sheet-modal');
                            if (modal) {
                                const btn = modal.querySelector(`button[onclick="addCharFromSheet('${info.sheetId}')"]`);
                                if (btn) {
                                    btn.style.boxShadow = '0 0 14px rgba(52,199,89,0.9)';
                                    btn.style.transform = 'translateY(-2px)';
                                    setTimeout(()=>{ btn.style.boxShadow=''; btn.style.transform=''; }, 2500);
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Erro ao destacar ficha recém-criada:', e);
                    }
                }, 300);
            }
            // Sincronizar itens quando atualizados da ficha
            else if (e.key === 'itemsUpdated') {
                loadItemsFromSheet();
            }
        });

// REMOVER PERSONAGEM DA ORDEM DE COMBATE (por id)
function removeCombatCharacter(id) {
    // Verificar se o ID é válido
    if (id === undefined || id === null || id === '') {
        console.error('removeCombatCharacter: ID inválido', id);
        return;
    }
    
    const idx = combatData.characters.findIndex(c => c.id === id);
    if (idx === -1) {
        console.error('removeCombatCharacter: Personagem não encontrado com ID', id);
        return;
    }

            const removed = combatData.characters.splice(idx, 1)[0];
            addLogEntry(`<strong>${removed.name}</strong> foi removido da ordem de iniciativa`);

            // Se não houver mais personagens, resetar estado ativo
            if (combatData.characters.length === 0) {
                combatData.currentTurn = 0;
                combatData.rounds = 0;
            }

            updateInitiativeList();
            updateActiveCharacter();
            updateTurnDisplay();
        }

        // AJUSTAR VALOR DE STAT (PV ou CO)
        function adjustStat(statType, amount) {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) return;

            // Inicializar controle de mudanças se não existir
            if (!statChanges[activeChar.id]) {
                statChanges[activeChar.id] = { hp: 0, co: 0 };
            }

            if (statType === 'hp') {
                const newHp = Math.max(0, Math.min(activeChar.maxHp, activeChar.hp + amount));
                activeChar.hp = newHp;
                statChanges[activeChar.id].hp += amount;
            } else if (statType === 'co') {
                const newCo = Math.max(0, Math.min(activeChar.maxCo, activeChar.co + amount));
                activeChar.co = newCo;
                statChanges[activeChar.id].co += amount;
            }

            updateActiveCharacter();
            updateInitiativeList();
        }

        // EDITAR VALOR DE STAT (clicando no texto)
        function editStat(statType) {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) return;

            const currentValue = statType === 'hp' ? activeChar.hp : activeChar.co;
            const maxValue = statType === 'hp' ? activeChar.maxHp : activeChar.maxCo;
            const statName = statType === 'hp' ? 'PV' : 'CO';
            const textElement = document.getElementById(statType + 'Text');

            // Criar input inline
            const input = document.createElement('input');
            input.type = 'number';
            input.min = '0';
            input.max = maxValue;
            input.value = currentValue;
            input.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-family: 'Orbitron', sans-serif;
                font-weight: 700;
                font-size: 0.9rem;
                color: white;
                background: rgba(0, 0, 0, 0.8);
                border: 2px solid var(--hexa-blue);
                border-radius: 4px;
                padding: 2px 8px;
                width: 80px;
                text-align: center;
                z-index: 20;
            `;

            // Substituir texto pelo input
            textElement.style.display = 'none';
            textElement.parentNode.appendChild(input);
            input.focus();
            input.select();

            // Função para salvar ou cancelar
            const saveOrCancel = () => {
                const newValue = parseInt(input.value);
                
                if (!isNaN(newValue) && newValue >= 0 && newValue <= maxValue) {
                    // Inicializar controle de mudanças se não existir
                    if (!statChanges[activeChar.id]) {
                        statChanges[activeChar.id] = { hp: 0, co: 0 };
                    }

                    const oldValue = currentValue;
                    const difference = newValue - oldValue;
                    
                    if (statType === 'hp') {
                        activeChar.hp = newValue;
                        statChanges[activeChar.id].hp += difference;
                    } else {
                        activeChar.co = newValue;
                        statChanges[activeChar.id].co += difference;
                    }
                    
                    updateActiveCharacter();
                    updateInitiativeList();
                }
                
                // Remover input e mostrar texto novamente
                input.remove();
                textElement.style.display = '';
            };

            // Eventos
            input.addEventListener('blur', saveOrCancel);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveOrCancel();
                } else if (e.key === 'Escape') {
                    input.remove();
                    textElement.style.display = '';
                }
            });
        }

        // REGISTRAR MUDANÇAS DE STATS NO LOG (chamado no final do turno)
        function logStatChanges() {
            Object.keys(statChanges).forEach(charId => {
                const char = combatData.characters.find(c => c.id == charId);
                if (!char) return;

                const changes = statChanges[charId];
                let logMessages = [];

                if (changes.hp !== 0) {
                    const action = changes.hp > 0 ? 'recebeu' : 'perdeu';
                    logMessages.push(`${action} ${Math.abs(changes.hp)} PV`);
                }

                if (changes.co !== 0) {
                    const action = changes.co > 0 ? 'ganhou' : 'perdeu';
                    logMessages.push(`${action} ${Math.abs(changes.co)} CO`);
                }

                if (logMessages.length > 0) {
                    addLogEntry(`${char.name} ${logMessages.join(' e ')} neste turno`, 
                               changes.hp > 0 ? 'heal' : 'damage');
                }
            });

            // Resetar mudanças após o log
            statChanges = {};
        }

        // SIMULAR EFEITOS SONOROS
        function playSoundEffect(type) {
            // Em uma implementação real, você tocaria arquivos de áudio
            console.log(`Som reproduzido: ${type}`);
        }

        // FUNÇÃO PARA TRATAR AÇÕES DO PERSONAGEM
        function takeAction(actionType) {
            const activeChar = combatData.characters.find(c => c.isActive);
            if (!activeChar) {
                addLogEntry('Nenhum personagem ativo encontrado!', 'turn');
                return;
            }

            switch(actionType) {
                case 'attack':
                    // Implementar lógica de ataque
                    addLogEntry(`${activeChar.name} prepara um ataque!`, 'damage');
                    playSoundEffect('attack');
                    break;
                
                case 'move':
                    // Implementar lógica de movimento
                    addLogEntry(`${activeChar.name} se move para uma nova posição!`, 'turn');
                    playSoundEffect('move');
                    break;
                
                case 'item':
                    // Abrir seção de itens ou alternar visibilidade
                    const quickActions = document.getElementById('quickActions');
                    const itemActions = document.getElementById('itemActions');
                    
                    if (itemActions && itemActions.style.display !== 'none') {
                        // Se já está visível, voltar para ações rápidas
                        itemActions.style.display = 'none';
                        quickActions.style.display = 'grid';
                    } else {
                        // Mostrar seção de itens
                        if (itemActions) {
                            itemActions.style.display = 'grid';
                        }
                        if (quickActions) {
                            quickActions.style.display = 'none';
                        }
                        // Carregar itens do personagem
                        loadItemsFromSheet();
                    }
                    break;
                
                default:
                    addLogEntry(`Ação desconhecida: ${actionType}`, 'turn');
            }
        }

        // setup do toggle de protocolos (colapsar/expandir)
        function setupProtocolsToggle() {
            const toggle = document.getElementById('protocolsToggle');
            const list = document.getElementById('protocolsList');
            const arrow = document.getElementById('protocolsArrow');
            if (!toggle || !list) return;
            toggle.addEventListener('click', () => {
                const expanded = list.style.display === 'block';
                if (expanded) {
                    list.style.display = 'none';
                    if (arrow) arrow.textContent = '›';
                    list.setAttribute('aria-hidden', 'true');
                } else {
                    list.style.display = 'block';
                    if (arrow) arrow.textContent = '˅';
                    list.setAttribute('aria-hidden', 'false');
                }
            });
        }

        // Sistema de Admin - Detecção de sequência de teclas
        let keySequence = '';
        const adminSequence = '1337'; // Sequência para ativar admin
        const adminPassword = 'adm1818'; // Senha do modo admin
        let isAdminMode = false;

        document.addEventListener('keydown', function(event) {
            // Ignorar se estiver em campos de input
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                return;
            }

            // Apenas teclas numéricas
            if (event.key >= '0' && event.key <= '9') {
                keySequence += event.key;
                
                // Manter apenas os últimos 4 dígitos
                if (keySequence.length > adminSequence.length) {
                    keySequence = keySequence.slice(-adminSequence.length);
                }

                // Verificar se a sequência corresponde
                if (keySequence === adminSequence && !isAdminMode) {
                    keySequence = ''; // Resetar sequência
                    showAdminPasswordPrompt();
                }
            }
        });

        function showAdminPasswordPrompt() {
            const password = prompt('🔐 Modo Admin - Digite a senha:');
            
            if (password === adminPassword) {
                activateAdminMode();
            } else if (password !== null) {
                alert('❌ Senha incorreta!');
                keySequence = ''; // Resetar em caso de falha
            }
        }

        function activateAdminMode() {
            isAdminMode = true;
            document.body.classList.add('admin-mode');
            
            // Criar painel admin
            const adminPanel = document.createElement('div');
            adminPanel.id = 'adminPanel';
            adminPanel.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 10000;
                min-width: 200px;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            `;
            
            adminPanel.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <strong>🔧 MODO ADMIN</strong>
                    <button onclick="exitAdminMode()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer;">✕</button>
                </div>
                <div style="font-size: 12px; opacity: 0.9;">
                    <div>• Debug ativo</div>
                    <div>• Console aberto</div>
                    <div>• Ferramentas disponíveis</div>
                </div>
                <button onclick="openDevTools()" style="margin-top: 10px; background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px; border-radius: 5px; cursor: pointer; width: 100%;">
                    Abrir DevTools
                </button>
                <button onclick="openHexaSocial()" style="margin-top: 5px; background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px; border-radius: 5px; cursor: pointer; width: 100%;">
                    🌐 H.E.X.A Social
                </button>
            `;
            
            document.body.appendChild(adminPanel);
            
            // Mostrar mensagem de boas-vindas
            showNotification('🔧 Modo Administrador ativado!', 'success');
            
            // Abrir console automaticamente
            console.log('%c🔧 MODO ADMIN ATIVADO 🔧', 'color: #667eea; font-size: 20px; font-weight: bold;');
            console.log('%cFerramentas administrativas disponíveis:', 'color: #764ba2; font-size: 14px;');
            console.log('- debugGame() : Debug do estado do jogo');
            console.log('- addExp(quantidade) : Adicionar experiência');
            console.log('- unlockAll() : Destravar todos os itens');
            
            // Adicionar funções admin ao window
            window.debugGame = function() {
                console.log('=== DEBUG DO JOGO ===');
                console.log('Personagem ativo:', activeChar);
                console.log('Modo admin:', isAdminMode);
                console.log('Itens:', items);
                console.log('Protocolos:', protocols);
            };
            
            window.addExp = function(amount) {
                if (activeChar) {
                    activeChar.experience.current = (activeChar.experience.current || 0) + amount;
                    updateCharacterInfo();
                    showNotification(`+${amount} EXP adicionado!`, 'success');
                }
            };
            
            window.unlockAll = function() {
                showNotification('Todos os itens destravados!', 'success');
            };
        }

        function exitAdminMode() {
            isAdminMode = false;
            document.body.classList.remove('admin-mode');
            const panel = document.getElementById('adminPanel');
            if (panel) panel.remove();
            showNotification('Modo administrador desativado', 'info');
        }

        function openDevTools() {
            // Tentar abrir DevTools (pode não funcionar em todos os browsers)
            if (typeof console !== 'undefined') {
                console.clear();
                console.log('%cDevTools Aberto - Modo Admin', 'background: #667eea; color: white; padding: 10px; border-radius: 5px;');
            }
        }

        function openHexaSocial() {
            window.open('hexa-social.html', '_blank');
        }

        // Adicionar estilos para modo admin
        const adminStyles = document.createElement('style');
        adminStyles.textContent = `
            .admin-mode {
                border: 2px solid #667eea !important;
                box-shadow: 0 0 20px rgba(102, 126, 234, 0.3) !important;
            }
            
            .admin-mode::before {
                content: '🔧 ADMIN';
                position: fixed;
                top: 0;
                left: 0;
                background: #667eea;
                color: white;
                padding: 5px 10px;
                font-size: 12px;
                z-index: 9999;
                opacity: 0.8;
            }
        `;
        document.head.appendChild(adminStyles);
    </script>

    <!-- Sistema de Autenticação e Sincronização -->
    <script src="js/hexa-config.js"></script>
    <script src="js/hexa-auth.js"></script>
    <script src="js/hexa-sync.js"></script>

    <!-- duplicata removida: #character-list já está dentro da sidebar -->
</body>